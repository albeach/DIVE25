{
  "version": 3,
  "sources": ["../src/builtins/json.js", "../node_modules/sprintf-js/src/sprintf.js", "../src/builtins/strings.js", "../src/builtins/regex.js", "../node_modules/yaml/dist/PlainValue-ec8e588e.js", "../node_modules/yaml/dist/parse-cst.js", "../node_modules/yaml/dist/resolveSeq-d03cb037.js", "../node_modules/yaml/dist/warnings-1000a372.js", "../node_modules/yaml/dist/Schema-88e323a7.js", "../node_modules/yaml/dist/Document-9b4560a1.js", "../node_modules/yaml/dist/index.js", "../node_modules/yaml/index.js", "../src/builtins/yaml.js", "../src/builtins/index.js", "../src/opa.js"],
  "sourcesContent": ["function isValidJSON(str) {\n  if (typeof str !== \"string\") {\n    return;\n  }\n  try {\n    JSON.parse(str);\n    return true;\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n      return false;\n    }\n    throw err;\n  }\n}\n\nmodule.exports = {\n  \"json.is_valid\": isValidJSON,\n};\n", "/* global window, exports, define */\n\n!function() {\n    'use strict'\n\n    var re = {\n        not_string: /[^s]/,\n        not_bool: /[^t]/,\n        not_type: /[^T]/,\n        not_primitive: /[^v]/,\n        number: /[diefg]/,\n        numeric_arg: /[bcdiefguxX]/,\n        json: /[j]/,\n        not_json: /[^j]/,\n        text: /^[^\\x25]+/,\n        modulo: /^\\x25{2}/,\n        placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-gijostTuvxX])/,\n        key: /^([a-z_][a-z_\\d]*)/i,\n        key_access: /^\\.([a-z_][a-z_\\d]*)/i,\n        index_access: /^\\[(\\d+)\\]/,\n        sign: /^[+-]/\n    }\n\n    function sprintf(key) {\n        // `arguments` is not an array, but should be fine for this call\n        return sprintf_format(sprintf_parse(key), arguments)\n    }\n\n    function vsprintf(fmt, argv) {\n        return sprintf.apply(null, [fmt].concat(argv || []))\n    }\n\n    function sprintf_format(parse_tree, argv) {\n        var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, ph, pad, pad_character, pad_length, is_positive, sign\n        for (i = 0; i < tree_length; i++) {\n            if (typeof parse_tree[i] === 'string') {\n                output += parse_tree[i]\n            }\n            else if (typeof parse_tree[i] === 'object') {\n                ph = parse_tree[i] // convenience purposes only\n                if (ph.keys) { // keyword argument\n                    arg = argv[cursor]\n                    for (k = 0; k < ph.keys.length; k++) {\n                        if (arg == undefined) {\n                            throw new Error(sprintf('[sprintf] Cannot access property \"%s\" of undefined value \"%s\"', ph.keys[k], ph.keys[k-1]))\n                        }\n                        arg = arg[ph.keys[k]]\n                    }\n                }\n                else if (ph.param_no) { // positional argument (explicit)\n                    arg = argv[ph.param_no]\n                }\n                else { // positional argument (implicit)\n                    arg = argv[cursor++]\n                }\n\n                if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {\n                    arg = arg()\n                }\n\n                if (re.numeric_arg.test(ph.type) && (typeof arg !== 'number' && isNaN(arg))) {\n                    throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg))\n                }\n\n                if (re.number.test(ph.type)) {\n                    is_positive = arg >= 0\n                }\n\n                switch (ph.type) {\n                    case 'b':\n                        arg = parseInt(arg, 10).toString(2)\n                        break\n                    case 'c':\n                        arg = String.fromCharCode(parseInt(arg, 10))\n                        break\n                    case 'd':\n                    case 'i':\n                        arg = parseInt(arg, 10)\n                        break\n                    case 'j':\n                        arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0)\n                        break\n                    case 'e':\n                        arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential()\n                        break\n                    case 'f':\n                        arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg)\n                        break\n                    case 'g':\n                        arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg)\n                        break\n                    case 'o':\n                        arg = (parseInt(arg, 10) >>> 0).toString(8)\n                        break\n                    case 's':\n                        arg = String(arg)\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 't':\n                        arg = String(!!arg)\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 'T':\n                        arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase()\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 'u':\n                        arg = parseInt(arg, 10) >>> 0\n                        break\n                    case 'v':\n                        arg = arg.valueOf()\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 'x':\n                        arg = (parseInt(arg, 10) >>> 0).toString(16)\n                        break\n                    case 'X':\n                        arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase()\n                        break\n                }\n                if (re.json.test(ph.type)) {\n                    output += arg\n                }\n                else {\n                    if (re.number.test(ph.type) && (!is_positive || ph.sign)) {\n                        sign = is_positive ? '+' : '-'\n                        arg = arg.toString().replace(re.sign, '')\n                    }\n                    else {\n                        sign = ''\n                    }\n                    pad_character = ph.pad_char ? ph.pad_char === '0' ? '0' : ph.pad_char.charAt(1) : ' '\n                    pad_length = ph.width - (sign + arg).length\n                    pad = ph.width ? (pad_length > 0 ? pad_character.repeat(pad_length) : '') : ''\n                    output += ph.align ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg)\n                }\n            }\n        }\n        return output\n    }\n\n    var sprintf_cache = Object.create(null)\n\n    function sprintf_parse(fmt) {\n        if (sprintf_cache[fmt]) {\n            return sprintf_cache[fmt]\n        }\n\n        var _fmt = fmt, match, parse_tree = [], arg_names = 0\n        while (_fmt) {\n            if ((match = re.text.exec(_fmt)) !== null) {\n                parse_tree.push(match[0])\n            }\n            else if ((match = re.modulo.exec(_fmt)) !== null) {\n                parse_tree.push('%')\n            }\n            else if ((match = re.placeholder.exec(_fmt)) !== null) {\n                if (match[2]) {\n                    arg_names |= 1\n                    var field_list = [], replacement_field = match[2], field_match = []\n                    if ((field_match = re.key.exec(replacement_field)) !== null) {\n                        field_list.push(field_match[1])\n                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\n                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {\n                                field_list.push(field_match[1])\n                            }\n                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {\n                                field_list.push(field_match[1])\n                            }\n                            else {\n                                throw new SyntaxError('[sprintf] failed to parse named argument key')\n                            }\n                        }\n                    }\n                    else {\n                        throw new SyntaxError('[sprintf] failed to parse named argument key')\n                    }\n                    match[2] = field_list\n                }\n                else {\n                    arg_names |= 2\n                }\n                if (arg_names === 3) {\n                    throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported')\n                }\n\n                parse_tree.push(\n                    {\n                        placeholder: match[0],\n                        param_no:    match[1],\n                        keys:        match[2],\n                        sign:        match[3],\n                        pad_char:    match[4],\n                        align:       match[5],\n                        width:       match[6],\n                        precision:   match[7],\n                        type:        match[8]\n                    }\n                )\n            }\n            else {\n                throw new SyntaxError('[sprintf] unexpected placeholder')\n            }\n            _fmt = _fmt.substring(match[0].length)\n        }\n        return sprintf_cache[fmt] = parse_tree\n    }\n\n    /**\n     * export to either browser or node.js\n     */\n    /* eslint-disable quote-props */\n    if (typeof exports !== 'undefined') {\n        exports['sprintf'] = sprintf\n        exports['vsprintf'] = vsprintf\n    }\n    if (typeof window !== 'undefined') {\n        window['sprintf'] = sprintf\n        window['vsprintf'] = vsprintf\n\n        if (typeof define === 'function' && define['amd']) {\n            define(function() {\n                return {\n                    'sprintf': sprintf,\n                    'vsprintf': vsprintf\n                }\n            })\n        }\n    }\n    /* eslint-enable quote-props */\n}(); // eslint-disable-line\n", "const vsprintf = require(\"sprintf-js\").vsprintf;\n\nconst sprintf = (s, values) => vsprintf(s, values);\n\nmodule.exports = { sprintf };\n", "const regexSplit = (pattern, s) => s.split(RegExp(pattern));\n\nmodule.exports = { \"regex.split\": regexSplit };\n", "'use strict';\n\nconst Char = {\n  ANCHOR: '&',\n  COMMENT: '#',\n  TAG: '!',\n  DIRECTIVES_END: '-',\n  DOCUMENT_END: '.'\n};\nconst Type = {\n  ALIAS: 'ALIAS',\n  BLANK_LINE: 'BLANK_LINE',\n  BLOCK_FOLDED: 'BLOCK_FOLDED',\n  BLOCK_LITERAL: 'BLOCK_LITERAL',\n  COMMENT: 'COMMENT',\n  DIRECTIVE: 'DIRECTIVE',\n  DOCUMENT: 'DOCUMENT',\n  FLOW_MAP: 'FLOW_MAP',\n  FLOW_SEQ: 'FLOW_SEQ',\n  MAP: 'MAP',\n  MAP_KEY: 'MAP_KEY',\n  MAP_VALUE: 'MAP_VALUE',\n  PLAIN: 'PLAIN',\n  QUOTE_DOUBLE: 'QUOTE_DOUBLE',\n  QUOTE_SINGLE: 'QUOTE_SINGLE',\n  SEQ: 'SEQ',\n  SEQ_ITEM: 'SEQ_ITEM'\n};\nconst defaultTagPrefix = 'tag:yaml.org,2002:';\nconst defaultTags = {\n  MAP: 'tag:yaml.org,2002:map',\n  SEQ: 'tag:yaml.org,2002:seq',\n  STR: 'tag:yaml.org,2002:str'\n};\n\nfunction findLineStarts(src) {\n  const ls = [0];\n  let offset = src.indexOf('\\n');\n\n  while (offset !== -1) {\n    offset += 1;\n    ls.push(offset);\n    offset = src.indexOf('\\n', offset);\n  }\n\n  return ls;\n}\n\nfunction getSrcInfo(cst) {\n  let lineStarts, src;\n\n  if (typeof cst === 'string') {\n    lineStarts = findLineStarts(cst);\n    src = cst;\n  } else {\n    if (Array.isArray(cst)) cst = cst[0];\n\n    if (cst && cst.context) {\n      if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);\n      lineStarts = cst.lineStarts;\n      src = cst.context.src;\n    }\n  }\n\n  return {\n    lineStarts,\n    src\n  };\n}\n/**\n * @typedef {Object} LinePos - One-indexed position in the source\n * @property {number} line\n * @property {number} col\n */\n\n/**\n * Determine the line/col position matching a character offset.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns a one-indexed `{ line, col }` location if found, or\n * `undefined` otherwise.\n *\n * @param {number} offset\n * @param {string|Document|Document[]} cst\n * @returns {?LinePos}\n */\n\n\nfunction getLinePos(offset, cst) {\n  if (typeof offset !== 'number' || offset < 0) return null;\n  const {\n    lineStarts,\n    src\n  } = getSrcInfo(cst);\n  if (!lineStarts || !src || offset > src.length) return null;\n\n  for (let i = 0; i < lineStarts.length; ++i) {\n    const start = lineStarts[i];\n\n    if (offset < start) {\n      return {\n        line: i,\n        col: offset - lineStarts[i - 1] + 1\n      };\n    }\n\n    if (offset === start) return {\n      line: i + 1,\n      col: 1\n    };\n  }\n\n  const line = lineStarts.length;\n  return {\n    line,\n    col: offset - lineStarts[line - 1] + 1\n  };\n}\n/**\n * Get a specified line from the source.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns the line as a string if found, or `null` otherwise.\n *\n * @param {number} line One-indexed line number\n * @param {string|Document|Document[]} cst\n * @returns {?string}\n */\n\nfunction getLine(line, cst) {\n  const {\n    lineStarts,\n    src\n  } = getSrcInfo(cst);\n  if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;\n  const start = lineStarts[line - 1];\n  let end = lineStarts[line]; // undefined for last line; that's ok for slice()\n\n  while (end && end > start && src[end - 1] === '\\n') --end;\n\n  return src.slice(start, end);\n}\n/**\n * Pretty-print the starting line from the source indicated by the range `pos`\n *\n * Trims output to `maxWidth` chars while keeping the starting column visible,\n * using `\u2026` at either end to indicate dropped characters.\n *\n * Returns a two-line string (or `null`) with `\\n` as separator; the second line\n * will hold appropriately indented `^` marks indicating the column range.\n *\n * @param {Object} pos\n * @param {LinePos} pos.start\n * @param {LinePos} [pos.end]\n * @param {string|Document|Document[]*} cst\n * @param {number} [maxWidth=80]\n * @returns {?string}\n */\n\nfunction getPrettyContext({\n  start,\n  end\n}, cst, maxWidth = 80) {\n  let src = getLine(start.line, cst);\n  if (!src) return null;\n  let {\n    col\n  } = start;\n\n  if (src.length > maxWidth) {\n    if (col <= maxWidth - 10) {\n      src = src.substr(0, maxWidth - 1) + '\u2026';\n    } else {\n      const halfWidth = Math.round(maxWidth / 2);\n      if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + '\u2026';\n      col -= src.length - maxWidth;\n      src = '\u2026' + src.substr(1 - maxWidth);\n    }\n  }\n\n  let errLen = 1;\n  let errEnd = '';\n\n  if (end) {\n    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {\n      errLen = end.col - start.col;\n    } else {\n      errLen = Math.min(src.length + 1, maxWidth) - col;\n      errEnd = '\u2026';\n    }\n  }\n\n  const offset = col > 1 ? ' '.repeat(col - 1) : '';\n  const err = '^'.repeat(errLen);\n  return `${src}\\n${offset}${err}${errEnd}`;\n}\n\nclass Range {\n  static copy(orig) {\n    return new Range(orig.start, orig.end);\n  }\n\n  constructor(start, end) {\n    this.start = start;\n    this.end = end || start;\n  }\n\n  isEmpty() {\n    return typeof this.start !== 'number' || !this.end || this.end <= this.start;\n  }\n  /**\n   * Set `origStart` and `origEnd` to point to the original source range for\n   * this node, which may differ due to dropped CR characters.\n   *\n   * @param {number[]} cr - Positions of dropped CR characters\n   * @param {number} offset - Starting index of `cr` from the last call\n   * @returns {number} - The next offset, matching the one found for `origStart`\n   */\n\n\n  setOrigRange(cr, offset) {\n    const {\n      start,\n      end\n    } = this;\n\n    if (cr.length === 0 || end <= cr[0]) {\n      this.origStart = start;\n      this.origEnd = end;\n      return offset;\n    }\n\n    let i = offset;\n\n    while (i < cr.length) {\n      if (cr[i] > start) break;else ++i;\n    }\n\n    this.origStart = start + i;\n    const nextOffset = i;\n\n    while (i < cr.length) {\n      // if end was at \\n, it should now be at \\r\n      if (cr[i] >= end) break;else ++i;\n    }\n\n    this.origEnd = end + i;\n    return nextOffset;\n  }\n\n}\n\n/** Root class of all nodes */\n\nclass Node {\n  static addStringTerminator(src, offset, str) {\n    if (str[str.length - 1] === '\\n') return str;\n    const next = Node.endOfWhiteSpace(src, offset);\n    return next >= src.length || src[next] === '\\n' ? str + '\\n' : str;\n  } // ^(---|...)\n\n\n  static atDocumentBoundary(src, offset, sep) {\n    const ch0 = src[offset];\n    if (!ch0) return true;\n    const prev = src[offset - 1];\n    if (prev && prev !== '\\n') return false;\n\n    if (sep) {\n      if (ch0 !== sep) return false;\n    } else {\n      if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;\n    }\n\n    const ch1 = src[offset + 1];\n    const ch2 = src[offset + 2];\n    if (ch1 !== ch0 || ch2 !== ch0) return false;\n    const ch3 = src[offset + 3];\n    return !ch3 || ch3 === '\\n' || ch3 === '\\t' || ch3 === ' ';\n  }\n\n  static endOfIdentifier(src, offset) {\n    let ch = src[offset];\n    const isVerbatim = ch === '<';\n    const notOk = isVerbatim ? ['\\n', '\\t', ' ', '>'] : ['\\n', '\\t', ' ', '[', ']', '{', '}', ','];\n\n    while (ch && notOk.indexOf(ch) === -1) ch = src[offset += 1];\n\n    if (isVerbatim && ch === '>') offset += 1;\n    return offset;\n  }\n\n  static endOfIndent(src, offset) {\n    let ch = src[offset];\n\n    while (ch === ' ') ch = src[offset += 1];\n\n    return offset;\n  }\n\n  static endOfLine(src, offset) {\n    let ch = src[offset];\n\n    while (ch && ch !== '\\n') ch = src[offset += 1];\n\n    return offset;\n  }\n\n  static endOfWhiteSpace(src, offset) {\n    let ch = src[offset];\n\n    while (ch === '\\t' || ch === ' ') ch = src[offset += 1];\n\n    return offset;\n  }\n\n  static startOfLine(src, offset) {\n    let ch = src[offset - 1];\n    if (ch === '\\n') return offset;\n\n    while (ch && ch !== '\\n') ch = src[offset -= 1];\n\n    return offset + 1;\n  }\n  /**\n   * End of indentation, or null if the line's indent level is not more\n   * than `indent`\n   *\n   * @param {string} src\n   * @param {number} indent\n   * @param {number} lineStart\n   * @returns {?number}\n   */\n\n\n  static endOfBlockIndent(src, indent, lineStart) {\n    const inEnd = Node.endOfIndent(src, lineStart);\n\n    if (inEnd > lineStart + indent) {\n      return inEnd;\n    } else {\n      const wsEnd = Node.endOfWhiteSpace(src, inEnd);\n      const ch = src[wsEnd];\n      if (!ch || ch === '\\n') return wsEnd;\n    }\n\n    return null;\n  }\n\n  static atBlank(src, offset, endAsBlank) {\n    const ch = src[offset];\n    return ch === '\\n' || ch === '\\t' || ch === ' ' || endAsBlank && !ch;\n  }\n\n  static nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {\n    if (!ch || indentDiff < 0) return false;\n    if (indentDiff > 0) return true;\n    return indicatorAsIndent && ch === '-';\n  } // should be at line or string end, or at next non-whitespace char\n\n\n  static normalizeOffset(src, offset) {\n    const ch = src[offset];\n    return !ch ? offset : ch !== '\\n' && src[offset - 1] === '\\n' ? offset - 1 : Node.endOfWhiteSpace(src, offset);\n  } // fold single newline into space, multiple newlines to N - 1 newlines\n  // presumes src[offset] === '\\n'\n\n\n  static foldNewline(src, offset, indent) {\n    let inCount = 0;\n    let error = false;\n    let fold = '';\n    let ch = src[offset + 1];\n\n    while (ch === ' ' || ch === '\\t' || ch === '\\n') {\n      switch (ch) {\n        case '\\n':\n          inCount = 0;\n          offset += 1;\n          fold += '\\n';\n          break;\n\n        case '\\t':\n          if (inCount <= indent) error = true;\n          offset = Node.endOfWhiteSpace(src, offset + 2) - 1;\n          break;\n\n        case ' ':\n          inCount += 1;\n          offset += 1;\n          break;\n      }\n\n      ch = src[offset + 1];\n    }\n\n    if (!fold) fold = ' ';\n    if (ch && inCount <= indent) error = true;\n    return {\n      fold,\n      offset,\n      error\n    };\n  }\n\n  constructor(type, props, context) {\n    Object.defineProperty(this, 'context', {\n      value: context || null,\n      writable: true\n    });\n    this.error = null;\n    this.range = null;\n    this.valueRange = null;\n    this.props = props || [];\n    this.type = type;\n    this.value = null;\n  }\n\n  getPropValue(idx, key, skipKey) {\n    if (!this.context) return null;\n    const {\n      src\n    } = this.context;\n    const prop = this.props[idx];\n    return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;\n  }\n\n  get anchor() {\n    for (let i = 0; i < this.props.length; ++i) {\n      const anchor = this.getPropValue(i, Char.ANCHOR, true);\n      if (anchor != null) return anchor;\n    }\n\n    return null;\n  }\n\n  get comment() {\n    const comments = [];\n\n    for (let i = 0; i < this.props.length; ++i) {\n      const comment = this.getPropValue(i, Char.COMMENT, true);\n      if (comment != null) comments.push(comment);\n    }\n\n    return comments.length > 0 ? comments.join('\\n') : null;\n  }\n\n  commentHasRequiredWhitespace(start) {\n    const {\n      src\n    } = this.context;\n    if (this.header && start === this.header.end) return false;\n    if (!this.valueRange) return false;\n    const {\n      end\n    } = this.valueRange;\n    return start !== end || Node.atBlank(src, end - 1);\n  }\n\n  get hasComment() {\n    if (this.context) {\n      const {\n        src\n      } = this.context;\n\n      for (let i = 0; i < this.props.length; ++i) {\n        if (src[this.props[i].start] === Char.COMMENT) return true;\n      }\n    }\n\n    return false;\n  }\n\n  get hasProps() {\n    if (this.context) {\n      const {\n        src\n      } = this.context;\n\n      for (let i = 0; i < this.props.length; ++i) {\n        if (src[this.props[i].start] !== Char.COMMENT) return true;\n      }\n    }\n\n    return false;\n  }\n\n  get includesTrailingLines() {\n    return false;\n  }\n\n  get jsonLike() {\n    const jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];\n    return jsonLikeTypes.indexOf(this.type) !== -1;\n  }\n\n  get rangeAsLinePos() {\n    if (!this.range || !this.context) return undefined;\n    const start = getLinePos(this.range.start, this.context.root);\n    if (!start) return undefined;\n    const end = getLinePos(this.range.end, this.context.root);\n    return {\n      start,\n      end\n    };\n  }\n\n  get rawValue() {\n    if (!this.valueRange || !this.context) return null;\n    const {\n      start,\n      end\n    } = this.valueRange;\n    return this.context.src.slice(start, end);\n  }\n\n  get tag() {\n    for (let i = 0; i < this.props.length; ++i) {\n      const tag = this.getPropValue(i, Char.TAG, false);\n\n      if (tag != null) {\n        if (tag[1] === '<') {\n          return {\n            verbatim: tag.slice(2, -1)\n          };\n        } else {\n          // eslint-disable-next-line no-unused-vars\n          const [_, handle, suffix] = tag.match(/^(.*!)([^!]*)$/);\n          return {\n            handle,\n            suffix\n          };\n        }\n      }\n    }\n\n    return null;\n  }\n\n  get valueRangeContainsNewline() {\n    if (!this.valueRange || !this.context) return false;\n    const {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      src\n    } = this.context;\n\n    for (let i = start; i < end; ++i) {\n      if (src[i] === '\\n') return true;\n    }\n\n    return false;\n  }\n\n  parseComment(start) {\n    const {\n      src\n    } = this.context;\n\n    if (src[start] === Char.COMMENT) {\n      const end = Node.endOfLine(src, start + 1);\n      const commentRange = new Range(start, end);\n      this.props.push(commentRange);\n      return end;\n    }\n\n    return start;\n  }\n  /**\n   * Populates the `origStart` and `origEnd` values of all ranges for this\n   * node. Extended by child classes to handle descendant nodes.\n   *\n   * @param {number[]} cr - Positions of dropped CR characters\n   * @param {number} offset - Starting index of `cr` from the last call\n   * @returns {number} - The next offset, matching the one found for `origStart`\n   */\n\n\n  setOrigRanges(cr, offset) {\n    if (this.range) offset = this.range.setOrigRange(cr, offset);\n    if (this.valueRange) this.valueRange.setOrigRange(cr, offset);\n    this.props.forEach(prop => prop.setOrigRange(cr, offset));\n    return offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    const str = src.slice(range.start, range.end);\n    return Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass YAMLError extends Error {\n  constructor(name, source, message) {\n    if (!message || !(source instanceof Node)) throw new Error(`Invalid arguments for new ${name}`);\n    super();\n    this.name = name;\n    this.message = message;\n    this.source = source;\n  }\n\n  makePretty() {\n    if (!this.source) return;\n    this.nodeType = this.source.type;\n    const cst = this.source.context && this.source.context.root;\n\n    if (typeof this.offset === 'number') {\n      this.range = new Range(this.offset, this.offset + 1);\n      const start = cst && getLinePos(this.offset, cst);\n\n      if (start) {\n        const end = {\n          line: start.line,\n          col: start.col + 1\n        };\n        this.linePos = {\n          start,\n          end\n        };\n      }\n\n      delete this.offset;\n    } else {\n      this.range = this.source.range;\n      this.linePos = this.source.rangeAsLinePos;\n    }\n\n    if (this.linePos) {\n      const {\n        line,\n        col\n      } = this.linePos.start;\n      this.message += ` at line ${line}, column ${col}`;\n      const ctx = cst && getPrettyContext(this.linePos, cst);\n      if (ctx) this.message += `:\\n\\n${ctx}\\n`;\n    }\n\n    delete this.source;\n  }\n\n}\nclass YAMLReferenceError extends YAMLError {\n  constructor(source, message) {\n    super('YAMLReferenceError', source, message);\n  }\n\n}\nclass YAMLSemanticError extends YAMLError {\n  constructor(source, message) {\n    super('YAMLSemanticError', source, message);\n  }\n\n}\nclass YAMLSyntaxError extends YAMLError {\n  constructor(source, message) {\n    super('YAMLSyntaxError', source, message);\n  }\n\n}\nclass YAMLWarning extends YAMLError {\n  constructor(source, message) {\n    super('YAMLWarning', source, message);\n  }\n\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nclass PlainValue extends Node {\n  static endOfLine(src, start, inFlow) {\n    let ch = src[start];\n    let offset = start;\n\n    while (ch && ch !== '\\n') {\n      if (inFlow && (ch === '[' || ch === ']' || ch === '{' || ch === '}' || ch === ',')) break;\n      const next = src[offset + 1];\n      if (ch === ':' && (!next || next === '\\n' || next === '\\t' || next === ' ' || inFlow && next === ',')) break;\n      if ((ch === ' ' || ch === '\\t') && next === '#') break;\n      offset += 1;\n      ch = next;\n    }\n\n    return offset;\n  }\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    let {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      src\n    } = this.context;\n    let ch = src[end - 1];\n\n    while (start < end && (ch === '\\n' || ch === '\\t' || ch === ' ')) ch = src[--end - 1];\n\n    let str = '';\n\n    for (let i = start; i < end; ++i) {\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        const {\n          fold,\n          offset\n        } = Node.foldNewline(src, i, -1);\n        str += fold;\n        i = offset;\n      } else if (ch === ' ' || ch === '\\t') {\n        // trim trailing whitespace\n        const wsStart = i;\n        let next = src[i + 1];\n\n        while (i < end && (next === ' ' || next === '\\t')) {\n          i += 1;\n          next = src[i + 1];\n        }\n\n        if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n      } else {\n        str += ch;\n      }\n    }\n\n    const ch0 = src[start];\n\n    switch (ch0) {\n      case '\\t':\n        {\n          const msg = 'Plain value cannot start with a tab character';\n          const errors = [new YAMLSemanticError(this, msg)];\n          return {\n            errors,\n            str\n          };\n        }\n\n      case '@':\n      case '`':\n        {\n          const msg = `Plain value cannot start with reserved character ${ch0}`;\n          const errors = [new YAMLSemanticError(this, msg)];\n          return {\n            errors,\n            str\n          };\n        }\n\n      default:\n        return str;\n    }\n  }\n\n  parseBlockValue(start) {\n    const {\n      indent,\n      inFlow,\n      src\n    } = this.context;\n    let offset = start;\n    let valueEnd = start;\n\n    for (let ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n      if (Node.atDocumentBoundary(src, offset + 1)) break;\n      const end = Node.endOfBlockIndent(src, indent, offset + 1);\n      if (end === null || src[end] === '#') break;\n\n      if (src[end] === '\\n') {\n        offset = end;\n      } else {\n        valueEnd = PlainValue.endOfLine(src, end, inFlow);\n        offset = valueEnd;\n      }\n    }\n\n    if (this.valueRange.isEmpty()) this.valueRange.start = start;\n    this.valueRange.end = valueEnd;\n    return valueEnd;\n  }\n  /**\n   * Parses a plain value from the source\n   *\n   * Accepted forms are:\n   * ```\n   * #comment\n   *\n   * first line\n   *\n   * first line #comment\n   *\n   * first line\n   * block\n   * lines\n   *\n   * #comment\n   * block\n   * lines\n   * ```\n   * where block lines are empty or have an indent level greater than `indent`.\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar, may be `\\n`\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      inFlow,\n      src\n    } = context;\n    let offset = start;\n    const ch = src[offset];\n\n    if (ch && ch !== '#' && ch !== '\\n') {\n      offset = PlainValue.endOfLine(src, start, inFlow);\n    }\n\n    this.valueRange = new Range(start, offset);\n    offset = Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n\n    if (!this.hasComment || this.valueRange.isEmpty()) {\n      offset = this.parseBlockValue(offset);\n    }\n\n    return offset;\n  }\n\n}\n\nexports.Char = Char;\nexports.Node = Node;\nexports.PlainValue = PlainValue;\nexports.Range = Range;\nexports.Type = Type;\nexports.YAMLError = YAMLError;\nexports.YAMLReferenceError = YAMLReferenceError;\nexports.YAMLSemanticError = YAMLSemanticError;\nexports.YAMLSyntaxError = YAMLSyntaxError;\nexports.YAMLWarning = YAMLWarning;\nexports._defineProperty = _defineProperty;\nexports.defaultTagPrefix = defaultTagPrefix;\nexports.defaultTags = defaultTags;\n", "'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\n\nclass BlankLine extends PlainValue.Node {\n  constructor() {\n    super(PlainValue.Type.BLANK_LINE);\n  }\n  /* istanbul ignore next */\n\n\n  get includesTrailingLines() {\n    // This is never called from anywhere, but if it were,\n    // this is the value it should return.\n    return true;\n  }\n  /**\n   * Parses a blank line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first \\n character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    this.range = new PlainValue.Range(start, start + 1);\n    return start + 1;\n  }\n\n}\n\nclass CollectionItem extends PlainValue.Node {\n  constructor(type, props) {\n    super(type, props);\n    this.node = null;\n  }\n\n  get includesTrailingLines() {\n    return !!this.node && this.node.includesTrailingLines;\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      parseNode,\n      src\n    } = context;\n    let {\n      atLineStart,\n      lineStart\n    } = context;\n    if (!atLineStart && this.type === PlainValue.Type.SEQ_ITEM) this.error = new PlainValue.YAMLSemanticError(this, 'Sequence items must not have preceding content on the same line');\n    const indent = atLineStart ? start - lineStart : context.indent;\n    let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);\n    let ch = src[offset];\n    const inlineComment = ch === '#';\n    const comments = [];\n    let blankLine = null;\n\n    while (ch === '\\n' || ch === '#') {\n      if (ch === '#') {\n        const end = PlainValue.Node.endOfLine(src, offset + 1);\n        comments.push(new PlainValue.Range(offset, end));\n        offset = end;\n      } else {\n        atLineStart = true;\n        lineStart = offset + 1;\n        const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);\n\n        if (src[wsEnd] === '\\n' && comments.length === 0) {\n          blankLine = new BlankLine();\n          lineStart = blankLine.parse({\n            src\n          }, lineStart);\n        }\n\n        offset = PlainValue.Node.endOfIndent(src, lineStart);\n      }\n\n      ch = src[offset];\n    }\n\n    if (PlainValue.Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== PlainValue.Type.SEQ_ITEM)) {\n      this.node = parseNode({\n        atLineStart,\n        inCollection: false,\n        indent,\n        lineStart,\n        parent: this\n      }, offset);\n    } else if (ch && lineStart > start + 1) {\n      offset = lineStart - 1;\n    }\n\n    if (this.node) {\n      if (blankLine) {\n        // Only blank lines preceding non-empty nodes are captured. Note that\n        // this means that collection item range start indices do not always\n        // increase monotonically. -- eemeli/yaml#126\n        const items = context.parent.items || context.parent.contents;\n        if (items) items.push(blankLine);\n      }\n\n      if (comments.length) Array.prototype.push.apply(this.props, comments);\n      offset = this.node.range.end;\n    } else {\n      if (inlineComment) {\n        const c = comments[0];\n        this.props.push(c);\n        offset = c.end;\n      } else {\n        offset = PlainValue.Node.endOfLine(src, start + 1);\n      }\n    }\n\n    const end = this.node ? this.node.valueRange.end : offset;\n    this.valueRange = new PlainValue.Range(start, end);\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    return this.node ? this.node.setOrigRanges(cr, offset) : offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      node,\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    const str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);\n    return PlainValue.Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass Comment extends PlainValue.Node {\n  constructor() {\n    super(PlainValue.Type.COMMENT);\n  }\n  /**\n   * Parses a comment line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const offset = this.parseComment(start);\n    this.range = new PlainValue.Range(start, offset);\n    return offset;\n  }\n\n}\n\nfunction grabCollectionEndComments(node) {\n  let cnode = node;\n\n  while (cnode instanceof CollectionItem) cnode = cnode.node;\n\n  if (!(cnode instanceof Collection)) return null;\n  const len = cnode.items.length;\n  let ci = -1;\n\n  for (let i = len - 1; i >= 0; --i) {\n    const n = cnode.items[i];\n\n    if (n.type === PlainValue.Type.COMMENT) {\n      // Keep sufficiently indented comments with preceding node\n      const {\n        indent,\n        lineStart\n      } = n.context;\n      if (indent > 0 && n.range.start >= lineStart + indent) break;\n      ci = i;\n    } else if (n.type === PlainValue.Type.BLANK_LINE) ci = i;else break;\n  }\n\n  if (ci === -1) return null;\n  const ca = cnode.items.splice(ci, len - ci);\n  const prevEnd = ca[0].range.start;\n\n  while (true) {\n    cnode.range.end = prevEnd;\n    if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;\n    if (cnode === node) break;\n    cnode = cnode.context.parent;\n  }\n\n  return ca;\n}\nclass Collection extends PlainValue.Node {\n  static nextContentHasIndent(src, offset, indent) {\n    const lineStart = PlainValue.Node.endOfLine(src, offset) + 1;\n    offset = PlainValue.Node.endOfWhiteSpace(src, lineStart);\n    const ch = src[offset];\n    if (!ch) return false;\n    if (offset >= lineStart + indent) return true;\n    if (ch !== '#' && ch !== '\\n') return false;\n    return Collection.nextContentHasIndent(src, offset, indent);\n  }\n\n  constructor(firstItem) {\n    super(firstItem.type === PlainValue.Type.SEQ_ITEM ? PlainValue.Type.SEQ : PlainValue.Type.MAP);\n\n    for (let i = firstItem.props.length - 1; i >= 0; --i) {\n      if (firstItem.props[i].start < firstItem.context.lineStart) {\n        // props on previous line are assumed by the collection\n        this.props = firstItem.props.slice(0, i + 1);\n        firstItem.props = firstItem.props.slice(i + 1);\n        const itemRange = firstItem.props[0] || firstItem.valueRange;\n        firstItem.range.start = itemRange.start;\n        break;\n      }\n    }\n\n    this.items = [firstItem];\n    const ec = grabCollectionEndComments(firstItem);\n    if (ec) Array.prototype.push.apply(this.items, ec);\n  }\n\n  get includesTrailingLines() {\n    return this.items.length > 0;\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      parseNode,\n      src\n    } = context; // It's easier to recalculate lineStart here rather than tracking down the\n    // last context from which to read it -- eemeli/yaml#2\n\n    let lineStart = PlainValue.Node.startOfLine(src, start);\n    const firstItem = this.items[0]; // First-item context needs to be correct for later comment handling\n    // -- eemeli/yaml#17\n\n    firstItem.context.parent = this;\n    this.valueRange = PlainValue.Range.copy(firstItem.valueRange);\n    const indent = firstItem.range.start - firstItem.context.lineStart;\n    let offset = start;\n    offset = PlainValue.Node.normalizeOffset(src, offset);\n    let ch = src[offset];\n    let atLineStart = PlainValue.Node.endOfWhiteSpace(src, lineStart) === offset;\n    let prevIncludesTrailingLines = false;\n\n    while (ch) {\n      while (ch === '\\n' || ch === '#') {\n        if (atLineStart && ch === '\\n' && !prevIncludesTrailingLines) {\n          const blankLine = new BlankLine();\n          offset = blankLine.parse({\n            src\n          }, offset);\n          this.valueRange.end = offset;\n\n          if (offset >= src.length) {\n            ch = null;\n            break;\n          }\n\n          this.items.push(blankLine);\n          offset -= 1; // blankLine.parse() consumes terminal newline\n        } else if (ch === '#') {\n          if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) {\n            return offset;\n          }\n\n          const comment = new Comment();\n          offset = comment.parse({\n            indent,\n            lineStart,\n            src\n          }, offset);\n          this.items.push(comment);\n          this.valueRange.end = offset;\n\n          if (offset >= src.length) {\n            ch = null;\n            break;\n          }\n        }\n\n        lineStart = offset + 1;\n        offset = PlainValue.Node.endOfIndent(src, lineStart);\n\n        if (PlainValue.Node.atBlank(src, offset)) {\n          const wsEnd = PlainValue.Node.endOfWhiteSpace(src, offset);\n          const next = src[wsEnd];\n\n          if (!next || next === '\\n' || next === '#') {\n            offset = wsEnd;\n          }\n        }\n\n        ch = src[offset];\n        atLineStart = true;\n      }\n\n      if (!ch) {\n        break;\n      }\n\n      if (offset !== lineStart + indent && (atLineStart || ch !== ':')) {\n        if (offset < lineStart + indent) {\n          if (lineStart > start) offset = lineStart;\n          break;\n        } else if (!this.error) {\n          const msg = 'All collection items must start at the same column';\n          this.error = new PlainValue.YAMLSyntaxError(this, msg);\n        }\n      }\n\n      if (firstItem.type === PlainValue.Type.SEQ_ITEM) {\n        if (ch !== '-') {\n          if (lineStart > start) offset = lineStart;\n          break;\n        }\n      } else if (ch === '-' && !this.error) {\n        // map key may start with -, as long as it's followed by a non-whitespace char\n        const next = src[offset + 1];\n\n        if (!next || next === '\\n' || next === '\\t' || next === ' ') {\n          const msg = 'A collection cannot be both a mapping and a sequence';\n          this.error = new PlainValue.YAMLSyntaxError(this, msg);\n        }\n      }\n\n      const node = parseNode({\n        atLineStart,\n        inCollection: true,\n        indent,\n        lineStart,\n        parent: this\n      }, offset);\n      if (!node) return offset; // at next document start\n\n      this.items.push(node);\n      this.valueRange.end = node.valueRange.end;\n      offset = PlainValue.Node.normalizeOffset(src, node.range.end);\n      ch = src[offset];\n      atLineStart = false;\n      prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range\n      // has advanced to check the current line's indentation level\n      // -- eemeli/yaml#10 & eemeli/yaml#38\n\n      if (ch) {\n        let ls = offset - 1;\n        let prev = src[ls];\n\n        while (prev === ' ' || prev === '\\t') prev = src[--ls];\n\n        if (prev === '\\n') {\n          lineStart = ls + 1;\n          atLineStart = true;\n        }\n      }\n\n      const ec = grabCollectionEndComments(node);\n      if (ec) Array.prototype.push.apply(this.items, ec);\n    }\n\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    this.items.forEach(node => {\n      offset = node.setOrigRanges(cr, offset);\n    });\n    return offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      items,\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    let str = src.slice(range.start, items[0].range.start) + String(items[0]);\n\n    for (let i = 1; i < items.length; ++i) {\n      const item = items[i];\n      const {\n        atLineStart,\n        indent\n      } = item.context;\n      if (atLineStart) for (let i = 0; i < indent; ++i) str += ' ';\n      str += String(item);\n    }\n\n    return PlainValue.Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass Directive extends PlainValue.Node {\n  constructor() {\n    super(PlainValue.Type.DIRECTIVE);\n    this.name = null;\n  }\n\n  get parameters() {\n    const raw = this.rawValue;\n    return raw ? raw.trim().split(/[ \\t]+/) : [];\n  }\n\n  parseName(start) {\n    const {\n      src\n    } = this.context;\n    let offset = start;\n    let ch = src[offset];\n\n    while (ch && ch !== '\\n' && ch !== '\\t' && ch !== ' ') ch = src[offset += 1];\n\n    this.name = src.slice(start, offset);\n    return offset;\n  }\n\n  parseParameters(start) {\n    const {\n      src\n    } = this.context;\n    let offset = start;\n    let ch = src[offset];\n\n    while (ch && ch !== '\\n' && ch !== '#') ch = src[offset += 1];\n\n    this.valueRange = new PlainValue.Range(start, offset);\n    return offset;\n  }\n\n  parse(context, start) {\n    this.context = context;\n    let offset = this.parseName(start + 1);\n    offset = this.parseParameters(offset);\n    offset = this.parseComment(offset);\n    this.range = new PlainValue.Range(start, offset);\n    return offset;\n  }\n\n}\n\nclass Document extends PlainValue.Node {\n  static startCommentOrEndBlankLine(src, start) {\n    const offset = PlainValue.Node.endOfWhiteSpace(src, start);\n    const ch = src[offset];\n    return ch === '#' || ch === '\\n' ? offset : start;\n  }\n\n  constructor() {\n    super(PlainValue.Type.DOCUMENT);\n    this.directives = null;\n    this.contents = null;\n    this.directivesEndMarker = null;\n    this.documentEndMarker = null;\n  }\n\n  parseDirectives(start) {\n    const {\n      src\n    } = this.context;\n    this.directives = [];\n    let atLineStart = true;\n    let hasDirectives = false;\n    let offset = start;\n\n    while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DIRECTIVES_END)) {\n      offset = Document.startCommentOrEndBlankLine(src, offset);\n\n      switch (src[offset]) {\n        case '\\n':\n          if (atLineStart) {\n            const blankLine = new BlankLine();\n            offset = blankLine.parse({\n              src\n            }, offset);\n\n            if (offset < src.length) {\n              this.directives.push(blankLine);\n            }\n          } else {\n            offset += 1;\n            atLineStart = true;\n          }\n\n          break;\n\n        case '#':\n          {\n            const comment = new Comment();\n            offset = comment.parse({\n              src\n            }, offset);\n            this.directives.push(comment);\n            atLineStart = false;\n          }\n          break;\n\n        case '%':\n          {\n            const directive = new Directive();\n            offset = directive.parse({\n              parent: this,\n              src\n            }, offset);\n            this.directives.push(directive);\n            hasDirectives = true;\n            atLineStart = false;\n          }\n          break;\n\n        default:\n          if (hasDirectives) {\n            this.error = new PlainValue.YAMLSemanticError(this, 'Missing directives-end indicator line');\n          } else if (this.directives.length > 0) {\n            this.contents = this.directives;\n            this.directives = [];\n          }\n\n          return offset;\n      }\n    }\n\n    if (src[offset]) {\n      this.directivesEndMarker = new PlainValue.Range(offset, offset + 3);\n      return offset + 3;\n    }\n\n    if (hasDirectives) {\n      this.error = new PlainValue.YAMLSemanticError(this, 'Missing directives-end indicator line');\n    } else if (this.directives.length > 0) {\n      this.contents = this.directives;\n      this.directives = [];\n    }\n\n    return offset;\n  }\n\n  parseContents(start) {\n    const {\n      parseNode,\n      src\n    } = this.context;\n    if (!this.contents) this.contents = [];\n    let lineStart = start;\n\n    while (src[lineStart - 1] === '-') lineStart -= 1;\n\n    let offset = PlainValue.Node.endOfWhiteSpace(src, start);\n    let atLineStart = lineStart === start;\n    this.valueRange = new PlainValue.Range(offset);\n\n    while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DOCUMENT_END)) {\n      switch (src[offset]) {\n        case '\\n':\n          if (atLineStart) {\n            const blankLine = new BlankLine();\n            offset = blankLine.parse({\n              src\n            }, offset);\n\n            if (offset < src.length) {\n              this.contents.push(blankLine);\n            }\n          } else {\n            offset += 1;\n            atLineStart = true;\n          }\n\n          lineStart = offset;\n          break;\n\n        case '#':\n          {\n            const comment = new Comment();\n            offset = comment.parse({\n              src\n            }, offset);\n            this.contents.push(comment);\n            atLineStart = false;\n          }\n          break;\n\n        default:\n          {\n            const iEnd = PlainValue.Node.endOfIndent(src, offset);\n            const context = {\n              atLineStart,\n              indent: -1,\n              inFlow: false,\n              inCollection: false,\n              lineStart,\n              parent: this\n            };\n            const node = parseNode(context, iEnd);\n            if (!node) return this.valueRange.end = iEnd; // at next document start\n\n            this.contents.push(node);\n            offset = node.range.end;\n            atLineStart = false;\n            const ec = grabCollectionEndComments(node);\n            if (ec) Array.prototype.push.apply(this.contents, ec);\n          }\n      }\n\n      offset = Document.startCommentOrEndBlankLine(src, offset);\n    }\n\n    this.valueRange.end = offset;\n\n    if (src[offset]) {\n      this.documentEndMarker = new PlainValue.Range(offset, offset + 3);\n      offset += 3;\n\n      if (src[offset]) {\n        offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n\n        if (src[offset] === '#') {\n          const comment = new Comment();\n          offset = comment.parse({\n            src\n          }, offset);\n          this.contents.push(comment);\n        }\n\n        switch (src[offset]) {\n          case '\\n':\n            offset += 1;\n            break;\n\n          case undefined:\n            break;\n\n          default:\n            this.error = new PlainValue.YAMLSyntaxError(this, 'Document end marker line cannot have a non-comment suffix');\n        }\n      }\n    }\n\n    return offset;\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    context.root = this;\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM\n\n    offset = this.parseDirectives(offset);\n    offset = this.parseContents(offset);\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    this.directives.forEach(node => {\n      offset = node.setOrigRanges(cr, offset);\n    });\n    if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);\n    this.contents.forEach(node => {\n      offset = node.setOrigRanges(cr, offset);\n    });\n    if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);\n    return offset;\n  }\n\n  toString() {\n    const {\n      contents,\n      directives,\n      value\n    } = this;\n    if (value != null) return value;\n    let str = directives.join('');\n\n    if (contents.length > 0) {\n      if (directives.length > 0 || contents[0].type === PlainValue.Type.COMMENT) str += '---\\n';\n      str += contents.join('');\n    }\n\n    if (str[str.length - 1] !== '\\n') str += '\\n';\n    return str;\n  }\n\n}\n\nclass Alias extends PlainValue.Node {\n  /**\n   * Parses an *alias from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = PlainValue.Node.endOfIdentifier(src, start + 1);\n    this.valueRange = new PlainValue.Range(start + 1, offset);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    return offset;\n  }\n\n}\n\nconst Chomp = {\n  CLIP: 'CLIP',\n  KEEP: 'KEEP',\n  STRIP: 'STRIP'\n};\nclass BlockValue extends PlainValue.Node {\n  constructor(type, props) {\n    super(type, props);\n    this.blockIndent = null;\n    this.chomping = Chomp.CLIP;\n    this.header = null;\n  }\n\n  get includesTrailingLines() {\n    return this.chomping === Chomp.KEEP;\n  }\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    let {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      indent,\n      src\n    } = this.context;\n    if (this.valueRange.isEmpty()) return '';\n    let lastNewLine = null;\n    let ch = src[end - 1];\n\n    while (ch === '\\n' || ch === '\\t' || ch === ' ') {\n      end -= 1;\n\n      if (end <= start) {\n        if (this.chomping === Chomp.KEEP) break;else return ''; // probably never happens\n      }\n\n      if (ch === '\\n') lastNewLine = end;\n      ch = src[end - 1];\n    }\n\n    let keepStart = end + 1;\n\n    if (lastNewLine) {\n      if (this.chomping === Chomp.KEEP) {\n        keepStart = lastNewLine;\n        end = this.valueRange.end;\n      } else {\n        end = lastNewLine;\n      }\n    }\n\n    const bi = indent + this.blockIndent;\n    const folded = this.type === PlainValue.Type.BLOCK_FOLDED;\n    let atStart = true;\n    let str = '';\n    let sep = '';\n    let prevMoreIndented = false;\n\n    for (let i = start; i < end; ++i) {\n      for (let j = 0; j < bi; ++j) {\n        if (src[i] !== ' ') break;\n        i += 1;\n      }\n\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        if (sep === '\\n') str += '\\n';else sep = '\\n';\n      } else {\n        const lineEnd = PlainValue.Node.endOfLine(src, i);\n        const line = src.slice(i, lineEnd);\n        i = lineEnd;\n\n        if (folded && (ch === ' ' || ch === '\\t') && i < keepStart) {\n          if (sep === ' ') sep = '\\n';else if (!prevMoreIndented && !atStart && sep === '\\n') sep = '\\n\\n';\n          str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')\n\n          sep = lineEnd < end && src[lineEnd] || '';\n          prevMoreIndented = true;\n        } else {\n          str += sep + line;\n          sep = folded && i < keepStart ? ' ' : '\\n';\n          prevMoreIndented = false;\n        }\n\n        if (atStart && line !== '') atStart = false;\n      }\n    }\n\n    return this.chomping === Chomp.STRIP ? str : str + '\\n';\n  }\n\n  parseBlockHeader(start) {\n    const {\n      src\n    } = this.context;\n    let offset = start + 1;\n    let bi = '';\n\n    while (true) {\n      const ch = src[offset];\n\n      switch (ch) {\n        case '-':\n          this.chomping = Chomp.STRIP;\n          break;\n\n        case '+':\n          this.chomping = Chomp.KEEP;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          bi += ch;\n          break;\n\n        default:\n          this.blockIndent = Number(bi) || null;\n          this.header = new PlainValue.Range(start, offset);\n          return offset;\n      }\n\n      offset += 1;\n    }\n  }\n\n  parseBlockValue(start) {\n    const {\n      indent,\n      src\n    } = this.context;\n    const explicit = !!this.blockIndent;\n    let offset = start;\n    let valueEnd = start;\n    let minBlockIndent = 1;\n\n    for (let ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n      offset += 1;\n      if (PlainValue.Node.atDocumentBoundary(src, offset)) break;\n      const end = PlainValue.Node.endOfBlockIndent(src, indent, offset); // should not include tab?\n\n      if (end === null) break;\n      const ch = src[end];\n      const lineIndent = end - (offset + indent);\n\n      if (!this.blockIndent) {\n        // no explicit block indent, none yet detected\n        if (src[end] !== '\\n') {\n          // first line with non-whitespace content\n          if (lineIndent < minBlockIndent) {\n            const msg = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n            this.error = new PlainValue.YAMLSemanticError(this, msg);\n          }\n\n          this.blockIndent = lineIndent;\n        } else if (lineIndent > minBlockIndent) {\n          // empty line with more whitespace\n          minBlockIndent = lineIndent;\n        }\n      } else if (ch && ch !== '\\n' && lineIndent < this.blockIndent) {\n        if (src[end] === '#') break;\n\n        if (!this.error) {\n          const src = explicit ? 'explicit indentation indicator' : 'first line';\n          const msg = `Block scalars must not be less indented than their ${src}`;\n          this.error = new PlainValue.YAMLSemanticError(this, msg);\n        }\n      }\n\n      if (src[end] === '\\n') {\n        offset = end;\n      } else {\n        offset = valueEnd = PlainValue.Node.endOfLine(src, end);\n      }\n    }\n\n    if (this.chomping !== Chomp.KEEP) {\n      offset = src[valueEnd] ? valueEnd + 1 : valueEnd;\n    }\n\n    this.valueRange = new PlainValue.Range(start + 1, offset);\n    return offset;\n  }\n  /**\n   * Parses a block value from the source\n   *\n   * Accepted forms are:\n   * ```\n   * BS\n   * block\n   * lines\n   *\n   * BS #comment\n   * block\n   * lines\n   * ```\n   * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines\n   * are empty or have an indent level greater than `indent`.\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this block\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = this.parseBlockHeader(start);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    offset = this.parseBlockValue(offset);\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    return this.header ? this.header.setOrigRange(cr, offset) : offset;\n  }\n\n}\n\nclass FlowCollection extends PlainValue.Node {\n  constructor(type, props) {\n    super(type, props);\n    this.items = null;\n  }\n\n  prevNodeIsJsonLike(idx = this.items.length) {\n    const node = this.items[idx - 1];\n    return !!node && (node.jsonLike || node.type === PlainValue.Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      parseNode,\n      src\n    } = context;\n    let {\n      indent,\n      lineStart\n    } = context;\n    let char = src[start]; // { or [\n\n    this.items = [{\n      char,\n      offset: start\n    }];\n    let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);\n    char = src[offset];\n\n    while (char && char !== ']' && char !== '}') {\n      switch (char) {\n        case '\\n':\n          {\n            lineStart = offset + 1;\n            const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);\n\n            if (src[wsEnd] === '\\n') {\n              const blankLine = new BlankLine();\n              lineStart = blankLine.parse({\n                src\n              }, lineStart);\n              this.items.push(blankLine);\n            }\n\n            offset = PlainValue.Node.endOfIndent(src, lineStart);\n\n            if (offset <= lineStart + indent) {\n              char = src[offset];\n\n              if (offset < lineStart + indent || char !== ']' && char !== '}') {\n                const msg = 'Insufficient indentation in flow collection';\n                this.error = new PlainValue.YAMLSemanticError(this, msg);\n              }\n            }\n          }\n          break;\n\n        case ',':\n          {\n            this.items.push({\n              char,\n              offset\n            });\n            offset += 1;\n          }\n          break;\n\n        case '#':\n          {\n            const comment = new Comment();\n            offset = comment.parse({\n              src\n            }, offset);\n            this.items.push(comment);\n          }\n          break;\n\n        case '?':\n        case ':':\n          {\n            const next = src[offset + 1];\n\n            if (next === '\\n' || next === '\\t' || next === ' ' || next === ',' || // in-flow : after JSON-like key does not need to be followed by whitespace\n            char === ':' && this.prevNodeIsJsonLike()) {\n              this.items.push({\n                char,\n                offset\n              });\n              offset += 1;\n              break;\n            }\n          }\n        // fallthrough\n\n        default:\n          {\n            const node = parseNode({\n              atLineStart: false,\n              inCollection: false,\n              inFlow: true,\n              indent: -1,\n              lineStart,\n              parent: this\n            }, offset);\n\n            if (!node) {\n              // at next document start\n              this.valueRange = new PlainValue.Range(start, offset);\n              return offset;\n            }\n\n            this.items.push(node);\n            offset = PlainValue.Node.normalizeOffset(src, node.range.end);\n          }\n      }\n\n      offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n      char = src[offset];\n    }\n\n    this.valueRange = new PlainValue.Range(start, offset + 1);\n\n    if (char) {\n      this.items.push({\n        char,\n        offset\n      });\n      offset = PlainValue.Node.endOfWhiteSpace(src, offset + 1);\n      offset = this.parseComment(offset);\n    }\n\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    this.items.forEach(node => {\n      if (node instanceof PlainValue.Node) {\n        offset = node.setOrigRanges(cr, offset);\n      } else if (cr.length === 0) {\n        node.origOffset = node.offset;\n      } else {\n        let i = offset;\n\n        while (i < cr.length) {\n          if (cr[i] > node.offset) break;else ++i;\n        }\n\n        node.origOffset = node.offset + i;\n        offset = i;\n      }\n    });\n    return offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      items,\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    const nodes = items.filter(item => item instanceof PlainValue.Node);\n    let str = '';\n    let prevEnd = range.start;\n    nodes.forEach(node => {\n      const prefix = src.slice(prevEnd, node.range.start);\n      prevEnd = node.range.end;\n      str += prefix + String(node);\n\n      if (str[str.length - 1] === '\\n' && src[prevEnd - 1] !== '\\n' && src[prevEnd] === '\\n') {\n        // Comment range does not include the terminal newline, but its\n        // stringified value does. Without this fix, newlines at comment ends\n        // get duplicated.\n        prevEnd += 1;\n      }\n    });\n    str += src.slice(prevEnd, range.end);\n    return PlainValue.Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass QuoteDouble extends PlainValue.Node {\n  static endOfQuote(src, offset) {\n    let ch = src[offset];\n\n    while (ch && ch !== '\"') {\n      offset += ch === '\\\\' ? 2 : 1;\n      ch = src[offset];\n    }\n\n    return offset + 1;\n  }\n  /**\n   * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n   */\n\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    const errors = [];\n    const {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      indent,\n      src\n    } = this.context;\n    if (src[end - 1] !== '\"') errors.push(new PlainValue.YAMLSyntaxError(this, 'Missing closing \"quote')); // Using String#replace is too painful with escaped newlines preceded by\n    // escaped backslashes; also, this should be faster.\n\n    let str = '';\n\n    for (let i = start + 1; i < end - 1; ++i) {\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n        const {\n          fold,\n          offset,\n          error\n        } = PlainValue.Node.foldNewline(src, i, indent);\n        str += fold;\n        i = offset;\n        if (error) errors.push(new PlainValue.YAMLSemanticError(this, 'Multi-line double-quoted string needs to be sufficiently indented'));\n      } else if (ch === '\\\\') {\n        i += 1;\n\n        switch (src[i]) {\n          case '0':\n            str += '\\0';\n            break;\n          // null character\n\n          case 'a':\n            str += '\\x07';\n            break;\n          // bell character\n\n          case 'b':\n            str += '\\b';\n            break;\n          // backspace\n\n          case 'e':\n            str += '\\x1b';\n            break;\n          // escape character\n\n          case 'f':\n            str += '\\f';\n            break;\n          // form feed\n\n          case 'n':\n            str += '\\n';\n            break;\n          // line feed\n\n          case 'r':\n            str += '\\r';\n            break;\n          // carriage return\n\n          case 't':\n            str += '\\t';\n            break;\n          // horizontal tab\n\n          case 'v':\n            str += '\\v';\n            break;\n          // vertical tab\n\n          case 'N':\n            str += '\\u0085';\n            break;\n          // Unicode next line\n\n          case '_':\n            str += '\\u00a0';\n            break;\n          // Unicode non-breaking space\n\n          case 'L':\n            str += '\\u2028';\n            break;\n          // Unicode line separator\n\n          case 'P':\n            str += '\\u2029';\n            break;\n          // Unicode paragraph separator\n\n          case ' ':\n            str += ' ';\n            break;\n\n          case '\"':\n            str += '\"';\n            break;\n\n          case '/':\n            str += '/';\n            break;\n\n          case '\\\\':\n            str += '\\\\';\n            break;\n\n          case '\\t':\n            str += '\\t';\n            break;\n\n          case 'x':\n            str += this.parseCharCode(i + 1, 2, errors);\n            i += 2;\n            break;\n\n          case 'u':\n            str += this.parseCharCode(i + 1, 4, errors);\n            i += 4;\n            break;\n\n          case 'U':\n            str += this.parseCharCode(i + 1, 8, errors);\n            i += 8;\n            break;\n\n          case '\\n':\n            // skip escaped newlines, but still trim the following line\n            while (src[i + 1] === ' ' || src[i + 1] === '\\t') i += 1;\n\n            break;\n\n          default:\n            errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(i - 1, 2)}`));\n            str += '\\\\' + src[i];\n        }\n      } else if (ch === ' ' || ch === '\\t') {\n        // trim trailing whitespace\n        const wsStart = i;\n        let next = src[i + 1];\n\n        while (next === ' ' || next === '\\t') {\n          i += 1;\n          next = src[i + 1];\n        }\n\n        if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n      } else {\n        str += ch;\n      }\n    }\n\n    return errors.length > 0 ? {\n      errors,\n      str\n    } : str;\n  }\n\n  parseCharCode(offset, length, errors) {\n    const {\n      src\n    } = this.context;\n    const cc = src.substr(offset, length);\n    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n    const code = ok ? parseInt(cc, 16) : NaN;\n\n    if (isNaN(code)) {\n      errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(offset - 2, length + 2)}`));\n      return src.substr(offset - 2, length + 2);\n    }\n\n    return String.fromCodePoint(code);\n  }\n  /**\n   * Parses a \"double quoted\" value from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = QuoteDouble.endOfQuote(src, start + 1);\n    this.valueRange = new PlainValue.Range(start, offset);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    return offset;\n  }\n\n}\n\nclass QuoteSingle extends PlainValue.Node {\n  static endOfQuote(src, offset) {\n    let ch = src[offset];\n\n    while (ch) {\n      if (ch === \"'\") {\n        if (src[offset + 1] !== \"'\") break;\n        ch = src[offset += 2];\n      } else {\n        ch = src[offset += 1];\n      }\n    }\n\n    return offset + 1;\n  }\n  /**\n   * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n   */\n\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    const errors = [];\n    const {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      indent,\n      src\n    } = this.context;\n    if (src[end - 1] !== \"'\") errors.push(new PlainValue.YAMLSyntaxError(this, \"Missing closing 'quote\"));\n    let str = '';\n\n    for (let i = start + 1; i < end - 1; ++i) {\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n        const {\n          fold,\n          offset,\n          error\n        } = PlainValue.Node.foldNewline(src, i, indent);\n        str += fold;\n        i = offset;\n        if (error) errors.push(new PlainValue.YAMLSemanticError(this, 'Multi-line single-quoted string needs to be sufficiently indented'));\n      } else if (ch === \"'\") {\n        str += ch;\n        i += 1;\n        if (src[i] !== \"'\") errors.push(new PlainValue.YAMLSyntaxError(this, 'Unescaped single quote? This should not happen.'));\n      } else if (ch === ' ' || ch === '\\t') {\n        // trim trailing whitespace\n        const wsStart = i;\n        let next = src[i + 1];\n\n        while (next === ' ' || next === '\\t') {\n          i += 1;\n          next = src[i + 1];\n        }\n\n        if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n      } else {\n        str += ch;\n      }\n    }\n\n    return errors.length > 0 ? {\n      errors,\n      str\n    } : str;\n  }\n  /**\n   * Parses a 'single quoted' value from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = QuoteSingle.endOfQuote(src, start + 1);\n    this.valueRange = new PlainValue.Range(start, offset);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    return offset;\n  }\n\n}\n\nfunction createNewNode(type, props) {\n  switch (type) {\n    case PlainValue.Type.ALIAS:\n      return new Alias(type, props);\n\n    case PlainValue.Type.BLOCK_FOLDED:\n    case PlainValue.Type.BLOCK_LITERAL:\n      return new BlockValue(type, props);\n\n    case PlainValue.Type.FLOW_MAP:\n    case PlainValue.Type.FLOW_SEQ:\n      return new FlowCollection(type, props);\n\n    case PlainValue.Type.MAP_KEY:\n    case PlainValue.Type.MAP_VALUE:\n    case PlainValue.Type.SEQ_ITEM:\n      return new CollectionItem(type, props);\n\n    case PlainValue.Type.COMMENT:\n    case PlainValue.Type.PLAIN:\n      return new PlainValue.PlainValue(type, props);\n\n    case PlainValue.Type.QUOTE_DOUBLE:\n      return new QuoteDouble(type, props);\n\n    case PlainValue.Type.QUOTE_SINGLE:\n      return new QuoteSingle(type, props);\n\n    /* istanbul ignore next */\n\n    default:\n      return null;\n    // should never happen\n  }\n}\n/**\n * @param {boolean} atLineStart - Node starts at beginning of line\n * @param {boolean} inFlow - true if currently in a flow context\n * @param {boolean} inCollection - true if currently in a collection context\n * @param {number} indent - Current level of indentation\n * @param {number} lineStart - Start of the current line\n * @param {Node} parent - The parent of the node\n * @param {string} src - Source of the YAML document\n */\n\n\nclass ParseContext {\n  static parseType(src, offset, inFlow) {\n    switch (src[offset]) {\n      case '*':\n        return PlainValue.Type.ALIAS;\n\n      case '>':\n        return PlainValue.Type.BLOCK_FOLDED;\n\n      case '|':\n        return PlainValue.Type.BLOCK_LITERAL;\n\n      case '{':\n        return PlainValue.Type.FLOW_MAP;\n\n      case '[':\n        return PlainValue.Type.FLOW_SEQ;\n\n      case '?':\n        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_KEY : PlainValue.Type.PLAIN;\n\n      case ':':\n        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_VALUE : PlainValue.Type.PLAIN;\n\n      case '-':\n        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.SEQ_ITEM : PlainValue.Type.PLAIN;\n\n      case '\"':\n        return PlainValue.Type.QUOTE_DOUBLE;\n\n      case \"'\":\n        return PlainValue.Type.QUOTE_SINGLE;\n\n      default:\n        return PlainValue.Type.PLAIN;\n    }\n  }\n\n  constructor(orig = {}, {\n    atLineStart,\n    inCollection,\n    inFlow,\n    indent,\n    lineStart,\n    parent\n  } = {}) {\n    PlainValue._defineProperty(this, \"parseNode\", (overlay, start) => {\n      if (PlainValue.Node.atDocumentBoundary(this.src, start)) return null;\n      const context = new ParseContext(this, overlay);\n      const {\n        props,\n        type,\n        valueStart\n      } = context.parseProps(start);\n      const node = createNewNode(type, props);\n      let offset = node.parse(context, valueStart);\n      node.range = new PlainValue.Range(start, offset);\n      /* istanbul ignore if */\n\n      if (offset <= start) {\n        // This should never happen, but if it does, let's make sure to at least\n        // step one character forward to avoid a busy loop.\n        node.error = new Error(`Node#parse consumed no characters`);\n        node.error.parseEnd = offset;\n        node.error.source = node;\n        node.range.end = start + 1;\n      }\n\n      if (context.nodeStartsCollection(node)) {\n        if (!node.error && !context.atLineStart && context.parent.type === PlainValue.Type.DOCUMENT) {\n          node.error = new PlainValue.YAMLSyntaxError(node, 'Block collection must not have preceding content here (e.g. directives-end indicator)');\n        }\n\n        const collection = new Collection(node);\n        offset = collection.parse(new ParseContext(context), offset);\n        collection.range = new PlainValue.Range(start, offset);\n        return collection;\n      }\n\n      return node;\n    });\n\n    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;\n    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;\n    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;\n    this.indent = indent != null ? indent : orig.indent;\n    this.lineStart = lineStart != null ? lineStart : orig.lineStart;\n    this.parent = parent != null ? parent : orig.parent || {};\n    this.root = orig.root;\n    this.src = orig.src;\n  }\n\n  nodeStartsCollection(node) {\n    const {\n      inCollection,\n      inFlow,\n      src\n    } = this;\n    if (inCollection || inFlow) return false;\n    if (node instanceof CollectionItem) return true; // check for implicit key\n\n    let offset = node.range.end;\n    if (src[offset] === '\\n' || src[offset - 1] === '\\n') return false;\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    return src[offset] === ':';\n  } // Anchor and tag are before type, which determines the node implementation\n  // class; hence this intermediate step.\n\n\n  parseProps(offset) {\n    const {\n      inFlow,\n      parent,\n      src\n    } = this;\n    const props = [];\n    let lineHasProps = false;\n    offset = this.atLineStart ? PlainValue.Node.endOfIndent(src, offset) : PlainValue.Node.endOfWhiteSpace(src, offset);\n    let ch = src[offset];\n\n    while (ch === PlainValue.Char.ANCHOR || ch === PlainValue.Char.COMMENT || ch === PlainValue.Char.TAG || ch === '\\n') {\n      if (ch === '\\n') {\n        let inEnd = offset;\n        let lineStart;\n\n        do {\n          lineStart = inEnd + 1;\n          inEnd = PlainValue.Node.endOfIndent(src, lineStart);\n        } while (src[inEnd] === '\\n');\n\n        const indentDiff = inEnd - (lineStart + this.indent);\n        const noIndicatorAsIndent = parent.type === PlainValue.Type.SEQ_ITEM && parent.context.atLineStart;\n        if (src[inEnd] !== '#' && !PlainValue.Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;\n        this.atLineStart = true;\n        this.lineStart = lineStart;\n        lineHasProps = false;\n        offset = inEnd;\n      } else if (ch === PlainValue.Char.COMMENT) {\n        const end = PlainValue.Node.endOfLine(src, offset + 1);\n        props.push(new PlainValue.Range(offset, end));\n        offset = end;\n      } else {\n        let end = PlainValue.Node.endOfIdentifier(src, offset + 1);\n\n        if (ch === PlainValue.Char.TAG && src[end] === ',' && /^[a-zA-Z0-9-]+\\.[a-zA-Z0-9-]+,\\d\\d\\d\\d(-\\d\\d){0,2}\\/\\S/.test(src.slice(offset + 1, end + 13))) {\n          // Let's presume we're dealing with a YAML 1.0 domain tag here, rather\n          // than an empty but 'foo.bar' private-tagged node in a flow collection\n          // followed without whitespace by a plain string starting with a year\n          // or date divided by something.\n          end = PlainValue.Node.endOfIdentifier(src, end + 5);\n        }\n\n        props.push(new PlainValue.Range(offset, end));\n        lineHasProps = true;\n        offset = PlainValue.Node.endOfWhiteSpace(src, end);\n      }\n\n      ch = src[offset];\n    } // '- &a : b' has an anchor on an empty node\n\n\n    if (lineHasProps && ch === ':' && PlainValue.Node.atBlank(src, offset + 1, true)) offset -= 1;\n    const type = ParseContext.parseType(src, offset, inFlow);\n    return {\n      props,\n      type,\n      valueStart: offset\n    };\n  }\n  /**\n   * Parses a node from the source\n   * @param {ParseContext} overlay\n   * @param {number} start - Index of first non-whitespace character for the node\n   * @returns {?Node} - null if at a document boundary\n   */\n\n\n}\n\n// Published as 'yaml/parse-cst'\nfunction parse(src) {\n  const cr = [];\n\n  if (src.indexOf('\\r') !== -1) {\n    src = src.replace(/\\r\\n?/g, (match, offset) => {\n      if (match.length > 1) cr.push(offset);\n      return '\\n';\n    });\n  }\n\n  const documents = [];\n  let offset = 0;\n\n  do {\n    const doc = new Document();\n    const context = new ParseContext({\n      src\n    });\n    offset = doc.parse(context, offset);\n    documents.push(doc);\n  } while (offset < src.length);\n\n  documents.setOrigRanges = () => {\n    if (cr.length === 0) return false;\n\n    for (let i = 1; i < cr.length; ++i) cr[i] -= i;\n\n    let crOffset = 0;\n\n    for (let i = 0; i < documents.length; ++i) {\n      crOffset = documents[i].setOrigRanges(cr, crOffset);\n    }\n\n    cr.splice(0, cr.length);\n    return true;\n  };\n\n  documents.toString = () => documents.join('...\\n');\n\n  return documents;\n}\n\nexports.parse = parse;\n", "'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\n\nfunction addCommentBefore(str, indent, comment) {\n  if (!comment) return str;\n  const cc = comment.replace(/[\\s\\S]^/gm, `$&${indent}#`);\n  return `#${cc}\\n${indent}${str}`;\n}\nfunction addComment(str, indent, comment) {\n  return !comment ? str : comment.indexOf('\\n') === -1 ? `${str} #${comment}` : `${str}\\n` + comment.replace(/^/gm, `${indent || ''}#`);\n}\n\nclass Node {}\n\nfunction toJSON(value, arg, ctx) {\n  if (Array.isArray(value)) return value.map((v, i) => toJSON(v, String(i), ctx));\n\n  if (value && typeof value.toJSON === 'function') {\n    const anchor = ctx && ctx.anchors && ctx.anchors.get(value);\n    if (anchor) ctx.onCreate = res => {\n      anchor.res = res;\n      delete ctx.onCreate;\n    };\n    const res = value.toJSON(arg, ctx);\n    if (anchor && ctx.onCreate) ctx.onCreate(res);\n    return res;\n  }\n\n  if ((!ctx || !ctx.keep) && typeof value === 'bigint') return Number(value);\n  return value;\n}\n\nclass Scalar extends Node {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n\n  toJSON(arg, ctx) {\n    return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);\n  }\n\n  toString() {\n    return String(this.value);\n  }\n\n}\n\nfunction collectionFromPath(schema, path, value) {\n  let v = value;\n\n  for (let i = path.length - 1; i >= 0; --i) {\n    const k = path[i];\n\n    if (Number.isInteger(k) && k >= 0) {\n      const a = [];\n      a[k] = v;\n      v = a;\n    } else {\n      const o = {};\n      Object.defineProperty(o, k, {\n        value: v,\n        writable: true,\n        enumerable: true,\n        configurable: true\n      });\n      v = o;\n    }\n  }\n\n  return schema.createNode(v, false);\n} // null, undefined, or an empty non-string iterable (e.g. [])\n\n\nconst isEmptyPath = path => path == null || typeof path === 'object' && path[Symbol.iterator]().next().done;\nclass Collection extends Node {\n  constructor(schema) {\n    super();\n\n    PlainValue._defineProperty(this, \"items\", []);\n\n    this.schema = schema;\n  }\n\n  addIn(path, value) {\n    if (isEmptyPath(path)) this.add(value);else {\n      const [key, ...rest] = path;\n      const node = this.get(key, true);\n      if (node instanceof Collection) node.addIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n  }\n\n  deleteIn([key, ...rest]) {\n    if (rest.length === 0) return this.delete(key);\n    const node = this.get(key, true);\n    if (node instanceof Collection) return node.deleteIn(rest);else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n  }\n\n  getIn([key, ...rest], keepScalar) {\n    const node = this.get(key, true);\n    if (rest.length === 0) return !keepScalar && node instanceof Scalar ? node.value : node;else return node instanceof Collection ? node.getIn(rest, keepScalar) : undefined;\n  }\n\n  hasAllNullValues() {\n    return this.items.every(node => {\n      if (!node || node.type !== 'PAIR') return false;\n      const n = node.value;\n      return n == null || n instanceof Scalar && n.value == null && !n.commentBefore && !n.comment && !n.tag;\n    });\n  }\n\n  hasIn([key, ...rest]) {\n    if (rest.length === 0) return this.has(key);\n    const node = this.get(key, true);\n    return node instanceof Collection ? node.hasIn(rest) : false;\n  }\n\n  setIn([key, ...rest], value) {\n    if (rest.length === 0) {\n      this.set(key, value);\n    } else {\n      const node = this.get(key, true);\n      if (node instanceof Collection) node.setIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n  } // overridden in implementations\n\n  /* istanbul ignore next */\n\n\n  toJSON() {\n    return null;\n  }\n\n  toString(ctx, {\n    blockItem,\n    flowChars,\n    isMap,\n    itemIndent\n  }, onComment, onChompKeep) {\n    const {\n      indent,\n      indentStep,\n      stringify\n    } = ctx;\n    const inFlow = this.type === PlainValue.Type.FLOW_MAP || this.type === PlainValue.Type.FLOW_SEQ || ctx.inFlow;\n    if (inFlow) itemIndent += indentStep;\n    const allNullValues = isMap && this.hasAllNullValues();\n    ctx = Object.assign({}, ctx, {\n      allNullValues,\n      indent: itemIndent,\n      inFlow,\n      type: null\n    });\n    let chompKeep = false;\n    let hasItemWithNewLine = false;\n    const nodes = this.items.reduce((nodes, item, i) => {\n      let comment;\n\n      if (item) {\n        if (!chompKeep && item.spaceBefore) nodes.push({\n          type: 'comment',\n          str: ''\n        });\n        if (item.commentBefore) item.commentBefore.match(/^.*$/gm).forEach(line => {\n          nodes.push({\n            type: 'comment',\n            str: `#${line}`\n          });\n        });\n        if (item.comment) comment = item.comment;\n        if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment))) hasItemWithNewLine = true;\n      }\n\n      chompKeep = false;\n      let str = stringify(item, ctx, () => comment = null, () => chompKeep = true);\n      if (inFlow && !hasItemWithNewLine && str.includes('\\n')) hasItemWithNewLine = true;\n      if (inFlow && i < this.items.length - 1) str += ',';\n      str = addComment(str, itemIndent, comment);\n      if (chompKeep && (comment || inFlow)) chompKeep = false;\n      nodes.push({\n        type: 'item',\n        str\n      });\n      return nodes;\n    }, []);\n    let str;\n\n    if (nodes.length === 0) {\n      str = flowChars.start + flowChars.end;\n    } else if (inFlow) {\n      const {\n        start,\n        end\n      } = flowChars;\n      const strings = nodes.map(n => n.str);\n\n      if (hasItemWithNewLine || strings.reduce((sum, str) => sum + str.length + 2, 2) > Collection.maxFlowStringSingleLineLength) {\n        str = start;\n\n        for (const s of strings) {\n          str += s ? `\\n${indentStep}${indent}${s}` : '\\n';\n        }\n\n        str += `\\n${indent}${end}`;\n      } else {\n        str = `${start} ${strings.join(' ')} ${end}`;\n      }\n    } else {\n      const strings = nodes.map(blockItem);\n      str = strings.shift();\n\n      for (const s of strings) str += s ? `\\n${indent}${s}` : '\\n';\n    }\n\n    if (this.comment) {\n      str += '\\n' + this.comment.replace(/^/gm, `${indent}#`);\n      if (onComment) onComment();\n    } else if (chompKeep && onChompKeep) onChompKeep();\n\n    return str;\n  }\n\n}\n\nPlainValue._defineProperty(Collection, \"maxFlowStringSingleLineLength\", 60);\n\nfunction asItemIndex(key) {\n  let idx = key instanceof Scalar ? key.value : key;\n  if (idx && typeof idx === 'string') idx = Number(idx);\n  return Number.isInteger(idx) && idx >= 0 ? idx : null;\n}\n\nclass YAMLSeq extends Collection {\n  add(value) {\n    this.items.push(value);\n  }\n\n  delete(key) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') return false;\n    const del = this.items.splice(idx, 1);\n    return del.length > 0;\n  }\n\n  get(key, keepScalar) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') return undefined;\n    const it = this.items[idx];\n    return !keepScalar && it instanceof Scalar ? it.value : it;\n  }\n\n  has(key) {\n    const idx = asItemIndex(key);\n    return typeof idx === 'number' && idx < this.items.length;\n  }\n\n  set(key, value) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') throw new Error(`Expected a valid index, not ${key}.`);\n    this.items[idx] = value;\n  }\n\n  toJSON(_, ctx) {\n    const seq = [];\n    if (ctx && ctx.onCreate) ctx.onCreate(seq);\n    let i = 0;\n\n    for (const item of this.items) seq.push(toJSON(item, String(i++), ctx));\n\n    return seq;\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx) return JSON.stringify(this);\n    return super.toString(ctx, {\n      blockItem: n => n.type === 'comment' ? n.str : `- ${n.str}`,\n      flowChars: {\n        start: '[',\n        end: ']'\n      },\n      isMap: false,\n      itemIndent: (ctx.indent || '') + '  '\n    }, onComment, onChompKeep);\n  }\n\n}\n\nconst stringifyKey = (key, jsKey, ctx) => {\n  if (jsKey === null) return '';\n  if (typeof jsKey !== 'object') return String(jsKey);\n  if (key instanceof Node && ctx && ctx.doc) return key.toString({\n    anchors: Object.create(null),\n    doc: ctx.doc,\n    indent: '',\n    indentStep: ctx.indentStep,\n    inFlow: true,\n    inStringifyKey: true,\n    stringify: ctx.stringify\n  });\n  return JSON.stringify(jsKey);\n};\n\nclass Pair extends Node {\n  constructor(key, value = null) {\n    super();\n    this.key = key;\n    this.value = value;\n    this.type = Pair.Type.PAIR;\n  }\n\n  get commentBefore() {\n    return this.key instanceof Node ? this.key.commentBefore : undefined;\n  }\n\n  set commentBefore(cb) {\n    if (this.key == null) this.key = new Scalar(null);\n    if (this.key instanceof Node) this.key.commentBefore = cb;else {\n      const msg = 'Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.';\n      throw new Error(msg);\n    }\n  }\n\n  addToJSMap(ctx, map) {\n    const key = toJSON(this.key, '', ctx);\n\n    if (map instanceof Map) {\n      const value = toJSON(this.value, key, ctx);\n      map.set(key, value);\n    } else if (map instanceof Set) {\n      map.add(key);\n    } else {\n      const stringKey = stringifyKey(this.key, key, ctx);\n      const value = toJSON(this.value, stringKey, ctx);\n      if (stringKey in map) Object.defineProperty(map, stringKey, {\n        value,\n        writable: true,\n        enumerable: true,\n        configurable: true\n      });else map[stringKey] = value;\n    }\n\n    return map;\n  }\n\n  toJSON(_, ctx) {\n    const pair = ctx && ctx.mapAsMap ? new Map() : {};\n    return this.addToJSMap(ctx, pair);\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx || !ctx.doc) return JSON.stringify(this);\n    const {\n      indent: indentSize,\n      indentSeq,\n      simpleKeys\n    } = ctx.doc.options;\n    let {\n      key,\n      value\n    } = this;\n    let keyComment = key instanceof Node && key.comment;\n\n    if (simpleKeys) {\n      if (keyComment) {\n        throw new Error('With simple keys, key nodes cannot have comments');\n      }\n\n      if (key instanceof Collection) {\n        const msg = 'With simple keys, collection cannot be used as a key value';\n        throw new Error(msg);\n      }\n    }\n\n    let explicitKey = !simpleKeys && (!key || keyComment || (key instanceof Node ? key instanceof Collection || key.type === PlainValue.Type.BLOCK_FOLDED || key.type === PlainValue.Type.BLOCK_LITERAL : typeof key === 'object'));\n    const {\n      doc,\n      indent,\n      indentStep,\n      stringify\n    } = ctx;\n    ctx = Object.assign({}, ctx, {\n      implicitKey: !explicitKey,\n      indent: indent + indentStep\n    });\n    let chompKeep = false;\n    let str = stringify(key, ctx, () => keyComment = null, () => chompKeep = true);\n    str = addComment(str, ctx.indent, keyComment);\n\n    if (!explicitKey && str.length > 1024) {\n      if (simpleKeys) throw new Error('With simple keys, single line scalar must not span more than 1024 characters');\n      explicitKey = true;\n    }\n\n    if (ctx.allNullValues && !simpleKeys) {\n      if (this.comment) {\n        str = addComment(str, ctx.indent, this.comment);\n        if (onComment) onComment();\n      } else if (chompKeep && !keyComment && onChompKeep) onChompKeep();\n\n      return ctx.inFlow && !explicitKey ? str : `? ${str}`;\n    }\n\n    str = explicitKey ? `? ${str}\\n${indent}:` : `${str}:`;\n\n    if (this.comment) {\n      // expected (but not strictly required) to be a single-line comment\n      str = addComment(str, ctx.indent, this.comment);\n      if (onComment) onComment();\n    }\n\n    let vcb = '';\n    let valueComment = null;\n\n    if (value instanceof Node) {\n      if (value.spaceBefore) vcb = '\\n';\n\n      if (value.commentBefore) {\n        const cs = value.commentBefore.replace(/^/gm, `${ctx.indent}#`);\n        vcb += `\\n${cs}`;\n      }\n\n      valueComment = value.comment;\n    } else if (value && typeof value === 'object') {\n      value = doc.schema.createNode(value, true);\n    }\n\n    ctx.implicitKey = false;\n    if (!explicitKey && !this.comment && value instanceof Scalar) ctx.indentAtStart = str.length + 1;\n    chompKeep = false;\n\n    if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== PlainValue.Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {\n      // If indentSeq === false, consider '- ' as part of indentation where possible\n      ctx.indent = ctx.indent.substr(2);\n    }\n\n    const valueStr = stringify(value, ctx, () => valueComment = null, () => chompKeep = true);\n    let ws = ' ';\n\n    if (vcb || this.comment) {\n      ws = `${vcb}\\n${ctx.indent}`;\n    } else if (!explicitKey && value instanceof Collection) {\n      const flow = valueStr[0] === '[' || valueStr[0] === '{';\n      if (!flow || valueStr.includes('\\n')) ws = `\\n${ctx.indent}`;\n    } else if (valueStr[0] === '\\n') ws = '';\n\n    if (chompKeep && !valueComment && onChompKeep) onChompKeep();\n    return addComment(str + ws + valueStr, ctx.indent, valueComment);\n  }\n\n}\n\nPlainValue._defineProperty(Pair, \"Type\", {\n  PAIR: 'PAIR',\n  MERGE_PAIR: 'MERGE_PAIR'\n});\n\nconst getAliasCount = (node, anchors) => {\n  if (node instanceof Alias) {\n    const anchor = anchors.get(node.source);\n    return anchor.count * anchor.aliasCount;\n  } else if (node instanceof Collection) {\n    let count = 0;\n\n    for (const item of node.items) {\n      const c = getAliasCount(item, anchors);\n      if (c > count) count = c;\n    }\n\n    return count;\n  } else if (node instanceof Pair) {\n    const kc = getAliasCount(node.key, anchors);\n    const vc = getAliasCount(node.value, anchors);\n    return Math.max(kc, vc);\n  }\n\n  return 1;\n};\n\nclass Alias extends Node {\n  static stringify({\n    range,\n    source\n  }, {\n    anchors,\n    doc,\n    implicitKey,\n    inStringifyKey\n  }) {\n    let anchor = Object.keys(anchors).find(a => anchors[a] === source);\n    if (!anchor && inStringifyKey) anchor = doc.anchors.getName(source) || doc.anchors.newName();\n    if (anchor) return `*${anchor}${implicitKey ? ' ' : ''}`;\n    const msg = doc.anchors.getName(source) ? 'Alias node must be after source node' : 'Source node not found for alias node';\n    throw new Error(`${msg} [${range}]`);\n  }\n\n  constructor(source) {\n    super();\n    this.source = source;\n    this.type = PlainValue.Type.ALIAS;\n  }\n\n  set tag(t) {\n    throw new Error('Alias nodes cannot have tags');\n  }\n\n  toJSON(arg, ctx) {\n    if (!ctx) return toJSON(this.source, arg, ctx);\n    const {\n      anchors,\n      maxAliasCount\n    } = ctx;\n    const anchor = anchors.get(this.source);\n    /* istanbul ignore if */\n\n    if (!anchor || anchor.res === undefined) {\n      const msg = 'This should not happen: Alias anchor was not resolved?';\n      if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);\n    }\n\n    if (maxAliasCount >= 0) {\n      anchor.count += 1;\n      if (anchor.aliasCount === 0) anchor.aliasCount = getAliasCount(this.source, anchors);\n\n      if (anchor.count * anchor.aliasCount > maxAliasCount) {\n        const msg = 'Excessive alias count indicates a resource exhaustion attack';\n        if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);\n      }\n    }\n\n    return anchor.res;\n  } // Only called when stringifying an alias mapping key while constructing\n  // Object output.\n\n\n  toString(ctx) {\n    return Alias.stringify(this, ctx);\n  }\n\n}\n\nPlainValue._defineProperty(Alias, \"default\", true);\n\nfunction findPair(items, key) {\n  const k = key instanceof Scalar ? key.value : key;\n\n  for (const it of items) {\n    if (it instanceof Pair) {\n      if (it.key === key || it.key === k) return it;\n      if (it.key && it.key.value === k) return it;\n    }\n  }\n\n  return undefined;\n}\nclass YAMLMap extends Collection {\n  add(pair, overwrite) {\n    if (!pair) pair = new Pair(pair);else if (!(pair instanceof Pair)) pair = new Pair(pair.key || pair, pair.value);\n    const prev = findPair(this.items, pair.key);\n    const sortEntries = this.schema && this.schema.sortMapEntries;\n\n    if (prev) {\n      if (overwrite) prev.value = pair.value;else throw new Error(`Key ${pair.key} already set`);\n    } else if (sortEntries) {\n      const i = this.items.findIndex(item => sortEntries(pair, item) < 0);\n      if (i === -1) this.items.push(pair);else this.items.splice(i, 0, pair);\n    } else {\n      this.items.push(pair);\n    }\n  }\n\n  delete(key) {\n    const it = findPair(this.items, key);\n    if (!it) return false;\n    const del = this.items.splice(this.items.indexOf(it), 1);\n    return del.length > 0;\n  }\n\n  get(key, keepScalar) {\n    const it = findPair(this.items, key);\n    const node = it && it.value;\n    return !keepScalar && node instanceof Scalar ? node.value : node;\n  }\n\n  has(key) {\n    return !!findPair(this.items, key);\n  }\n\n  set(key, value) {\n    this.add(new Pair(key, value), true);\n  }\n  /**\n   * @param {*} arg ignored\n   * @param {*} ctx Conversion context, originally set in Document#toJSON()\n   * @param {Class} Type If set, forces the returned collection type\n   * @returns {*} Instance of Type, Map, or Object\n   */\n\n\n  toJSON(_, ctx, Type) {\n    const map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};\n    if (ctx && ctx.onCreate) ctx.onCreate(map);\n\n    for (const item of this.items) item.addToJSMap(ctx, map);\n\n    return map;\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx) return JSON.stringify(this);\n\n    for (const item of this.items) {\n      if (!(item instanceof Pair)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);\n    }\n\n    return super.toString(ctx, {\n      blockItem: n => n.str,\n      flowChars: {\n        start: '{',\n        end: '}'\n      },\n      isMap: true,\n      itemIndent: ctx.indent || ''\n    }, onComment, onChompKeep);\n  }\n\n}\n\nconst MERGE_KEY = '<<';\nclass Merge extends Pair {\n  constructor(pair) {\n    if (pair instanceof Pair) {\n      let seq = pair.value;\n\n      if (!(seq instanceof YAMLSeq)) {\n        seq = new YAMLSeq();\n        seq.items.push(pair.value);\n        seq.range = pair.value.range;\n      }\n\n      super(pair.key, seq);\n      this.range = pair.range;\n    } else {\n      super(new Scalar(MERGE_KEY), new YAMLSeq());\n    }\n\n    this.type = Pair.Type.MERGE_PAIR;\n  } // If the value associated with a merge key is a single mapping node, each of\n  // its key/value pairs is inserted into the current mapping, unless the key\n  // already exists in it. If the value associated with the merge key is a\n  // sequence, then this sequence is expected to contain mapping nodes and each\n  // of these nodes is merged in turn according to its order in the sequence.\n  // Keys in mapping nodes earlier in the sequence override keys specified in\n  // later mapping nodes. -- http://yaml.org/type/merge.html\n\n\n  addToJSMap(ctx, map) {\n    for (const {\n      source\n    } of this.value.items) {\n      if (!(source instanceof YAMLMap)) throw new Error('Merge sources must be maps');\n      const srcMap = source.toJSON(null, ctx, Map);\n\n      for (const [key, value] of srcMap) {\n        if (map instanceof Map) {\n          if (!map.has(key)) map.set(key, value);\n        } else if (map instanceof Set) {\n          map.add(key);\n        } else if (!Object.prototype.hasOwnProperty.call(map, key)) {\n          Object.defineProperty(map, key, {\n            value,\n            writable: true,\n            enumerable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n\n    return map;\n  }\n\n  toString(ctx, onComment) {\n    const seq = this.value;\n    if (seq.items.length > 1) return super.toString(ctx, onComment);\n    this.value = seq.items[0];\n    const str = super.toString(ctx, onComment);\n    this.value = seq;\n    return str;\n  }\n\n}\n\nconst binaryOptions = {\n  defaultType: PlainValue.Type.BLOCK_LITERAL,\n  lineWidth: 76\n};\nconst boolOptions = {\n  trueStr: 'true',\n  falseStr: 'false'\n};\nconst intOptions = {\n  asBigInt: false\n};\nconst nullOptions = {\n  nullStr: 'null'\n};\nconst strOptions = {\n  defaultType: PlainValue.Type.PLAIN,\n  doubleQuoted: {\n    jsonEncoding: false,\n    minMultiLineLength: 40\n  },\n  fold: {\n    lineWidth: 80,\n    minContentWidth: 20\n  }\n};\n\nfunction resolveScalar(str, tags, scalarFallback) {\n  for (const {\n    format,\n    test,\n    resolve\n  } of tags) {\n    if (test) {\n      const match = str.match(test);\n\n      if (match) {\n        let res = resolve.apply(null, match);\n        if (!(res instanceof Scalar)) res = new Scalar(res);\n        if (format) res.format = format;\n        return res;\n      }\n    }\n  }\n\n  if (scalarFallback) str = scalarFallback(str);\n  return new Scalar(str);\n}\n\nconst FOLD_FLOW = 'flow';\nconst FOLD_BLOCK = 'block';\nconst FOLD_QUOTED = 'quoted'; // presumes i+1 is at the start of a line\n// returns index of last newline in more-indented block\n\nconst consumeMoreIndentedLines = (text, i) => {\n  let ch = text[i + 1];\n\n  while (ch === ' ' || ch === '\\t') {\n    do {\n      ch = text[i += 1];\n    } while (ch && ch !== '\\n');\n\n    ch = text[i + 1];\n  }\n\n  return i;\n};\n/**\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\n * terminated with `\\n` and started with `indent`.\n *\n * @param {string} text\n * @param {string} indent\n * @param {string} [mode='flow'] `'block'` prevents more-indented lines\n *   from being folded; `'quoted'` allows for `\\` escapes, including escaped\n *   newlines\n * @param {Object} options\n * @param {number} [options.indentAtStart] Accounts for leading contents on\n *   the first line, defaulting to `indent.length`\n * @param {number} [options.lineWidth=80]\n * @param {number} [options.minContentWidth=20] Allow highly indented lines to\n *   stretch the line width or indent content from the start\n * @param {function} options.onFold Called once if the text is folded\n * @param {function} options.onFold Called once if any line of text exceeds\n *   lineWidth characters\n */\n\n\nfunction foldFlowLines(text, indent, mode, {\n  indentAtStart,\n  lineWidth = 80,\n  minContentWidth = 20,\n  onFold,\n  onOverflow\n}) {\n  if (!lineWidth || lineWidth < 0) return text;\n  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\n  if (text.length <= endStep) return text;\n  const folds = [];\n  const escapedFolds = {};\n  let end = lineWidth - indent.length;\n\n  if (typeof indentAtStart === 'number') {\n    if (indentAtStart > lineWidth - Math.max(2, minContentWidth)) folds.push(0);else end = lineWidth - indentAtStart;\n  }\n\n  let split = undefined;\n  let prev = undefined;\n  let overflow = false;\n  let i = -1;\n  let escStart = -1;\n  let escEnd = -1;\n\n  if (mode === FOLD_BLOCK) {\n    i = consumeMoreIndentedLines(text, i);\n    if (i !== -1) end = i + endStep;\n  }\n\n  for (let ch; ch = text[i += 1];) {\n    if (mode === FOLD_QUOTED && ch === '\\\\') {\n      escStart = i;\n\n      switch (text[i + 1]) {\n        case 'x':\n          i += 3;\n          break;\n\n        case 'u':\n          i += 5;\n          break;\n\n        case 'U':\n          i += 9;\n          break;\n\n        default:\n          i += 1;\n      }\n\n      escEnd = i;\n    }\n\n    if (ch === '\\n') {\n      if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i);\n      end = i + endStep;\n      split = undefined;\n    } else {\n      if (ch === ' ' && prev && prev !== ' ' && prev !== '\\n' && prev !== '\\t') {\n        // space surrounded by non-space can be replaced with newline + indent\n        const next = text[i + 1];\n        if (next && next !== ' ' && next !== '\\n' && next !== '\\t') split = i;\n      }\n\n      if (i >= end) {\n        if (split) {\n          folds.push(split);\n          end = split + endStep;\n          split = undefined;\n        } else if (mode === FOLD_QUOTED) {\n          // white-space collected at end may stretch past lineWidth\n          while (prev === ' ' || prev === '\\t') {\n            prev = ch;\n            ch = text[i += 1];\n            overflow = true;\n          } // Account for newline escape, but don't break preceding escape\n\n\n          const j = i > escEnd + 1 ? i - 2 : escStart - 1; // Bail out if lineWidth & minContentWidth are shorter than an escape string\n\n          if (escapedFolds[j]) return text;\n          folds.push(j);\n          escapedFolds[j] = true;\n          end = j + endStep;\n          split = undefined;\n        } else {\n          overflow = true;\n        }\n      }\n    }\n\n    prev = ch;\n  }\n\n  if (overflow && onOverflow) onOverflow();\n  if (folds.length === 0) return text;\n  if (onFold) onFold();\n  let res = text.slice(0, folds[0]);\n\n  for (let i = 0; i < folds.length; ++i) {\n    const fold = folds[i];\n    const end = folds[i + 1] || text.length;\n    if (fold === 0) res = `\\n${indent}${text.slice(0, end)}`;else {\n      if (mode === FOLD_QUOTED && escapedFolds[fold]) res += `${text[fold]}\\\\`;\n      res += `\\n${indent}${text.slice(fold + 1, end)}`;\n    }\n  }\n\n  return res;\n}\n\nconst getFoldOptions = ({\n  indentAtStart\n}) => indentAtStart ? Object.assign({\n  indentAtStart\n}, strOptions.fold) : strOptions.fold; // Also checks for lines starting with %, as parsing the output as YAML 1.1 will\n// presume that's starting a new document.\n\n\nconst containsDocumentMarker = str => /^(%|---|\\.\\.\\.)/m.test(str);\n\nfunction lineLengthOverLimit(str, lineWidth, indentLength) {\n  if (!lineWidth || lineWidth < 0) return false;\n  const limit = lineWidth - indentLength;\n  const strLen = str.length;\n  if (strLen <= limit) return false;\n\n  for (let i = 0, start = 0; i < strLen; ++i) {\n    if (str[i] === '\\n') {\n      if (i - start > limit) return true;\n      start = i + 1;\n      if (strLen - start <= limit) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction doubleQuotedString(value, ctx) {\n  const {\n    implicitKey\n  } = ctx;\n  const {\n    jsonEncoding,\n    minMultiLineLength\n  } = strOptions.doubleQuoted;\n  const json = JSON.stringify(value);\n  if (jsonEncoding) return json;\n  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  let str = '';\n  let start = 0;\n\n  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {\n    if (ch === ' ' && json[i + 1] === '\\\\' && json[i + 2] === 'n') {\n      // space before newline needs to be escaped to not be folded\n      str += json.slice(start, i) + '\\\\ ';\n      i += 1;\n      start = i;\n      ch = '\\\\';\n    }\n\n    if (ch === '\\\\') switch (json[i + 1]) {\n      case 'u':\n        {\n          str += json.slice(start, i);\n          const code = json.substr(i + 2, 4);\n\n          switch (code) {\n            case '0000':\n              str += '\\\\0';\n              break;\n\n            case '0007':\n              str += '\\\\a';\n              break;\n\n            case '000b':\n              str += '\\\\v';\n              break;\n\n            case '001b':\n              str += '\\\\e';\n              break;\n\n            case '0085':\n              str += '\\\\N';\n              break;\n\n            case '00a0':\n              str += '\\\\_';\n              break;\n\n            case '2028':\n              str += '\\\\L';\n              break;\n\n            case '2029':\n              str += '\\\\P';\n              break;\n\n            default:\n              if (code.substr(0, 2) === '00') str += '\\\\x' + code.substr(2);else str += json.substr(i, 6);\n          }\n\n          i += 5;\n          start = i + 1;\n        }\n        break;\n\n      case 'n':\n        if (implicitKey || json[i + 2] === '\"' || json.length < minMultiLineLength) {\n          i += 1;\n        } else {\n          // folding will eat first newline\n          str += json.slice(start, i) + '\\n\\n';\n\n          while (json[i + 2] === '\\\\' && json[i + 3] === 'n' && json[i + 4] !== '\"') {\n            str += '\\n';\n            i += 2;\n          }\n\n          str += indent; // space after newline needs to be escaped to not be folded\n\n          if (json[i + 2] === ' ') str += '\\\\';\n          i += 1;\n          start = i + 1;\n        }\n\n        break;\n\n      default:\n        i += 1;\n    }\n  }\n\n  str = start ? str + json.slice(start) : json;\n  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));\n}\n\nfunction singleQuotedString(value, ctx) {\n  if (ctx.implicitKey) {\n    if (/\\n/.test(value)) return doubleQuotedString(value, ctx);\n  } else {\n    // single quoted string can't have leading or trailing whitespace around newline\n    if (/[ \\t]\\n|\\n[ \\t]/.test(value)) return doubleQuotedString(value, ctx);\n  }\n\n  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  const res = \"'\" + value.replace(/'/g, \"''\").replace(/\\n+/g, `$&\\n${indent}`) + \"'\";\n  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));\n}\n\nfunction blockString({\n  comment,\n  type,\n  value\n}, ctx, onComment, onChompKeep) {\n  // 1. Block can't end in whitespace unless the last line is non-empty.\n  // 2. Strings consisting of only whitespace are best rendered explicitly.\n  if (/\\n[\\t ]+$/.test(value) || /^\\s*$/.test(value)) {\n    return doubleQuotedString(value, ctx);\n  }\n\n  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');\n  const indentSize = indent ? '2' : '1'; // root is at -1\n\n  const literal = type === PlainValue.Type.BLOCK_FOLDED ? false : type === PlainValue.Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth, indent.length);\n  let header = literal ? '|' : '>';\n  if (!value) return header + '\\n';\n  let wsStart = '';\n  let wsEnd = '';\n  value = value.replace(/[\\n\\t ]*$/, ws => {\n    const n = ws.indexOf('\\n');\n\n    if (n === -1) {\n      header += '-'; // strip\n    } else if (value === ws || n !== ws.length - 1) {\n      header += '+'; // keep\n\n      if (onChompKeep) onChompKeep();\n    }\n\n    wsEnd = ws.replace(/\\n$/, '');\n    return '';\n  }).replace(/^[\\n ]*/, ws => {\n    if (ws.indexOf(' ') !== -1) header += indentSize;\n    const m = ws.match(/ +$/);\n\n    if (m) {\n      wsStart = ws.slice(0, -m[0].length);\n      return m[0];\n    } else {\n      wsStart = ws;\n      return '';\n    }\n  });\n  if (wsEnd) wsEnd = wsEnd.replace(/\\n+(?!\\n|$)/g, `$&${indent}`);\n  if (wsStart) wsStart = wsStart.replace(/\\n+/g, `$&${indent}`);\n\n  if (comment) {\n    header += ' #' + comment.replace(/ ?[\\r\\n]+/g, ' ');\n    if (onComment) onComment();\n  }\n\n  if (!value) return `${header}${indentSize}\\n${indent}${wsEnd}`;\n\n  if (literal) {\n    value = value.replace(/\\n+/g, `$&${indent}`);\n    return `${header}\\n${indent}${wsStart}${value}${wsEnd}`;\n  }\n\n  value = value.replace(/\\n+/g, '\\n$&').replace(/(?:^|\\n)([\\t ].*)(?:([\\n\\t ]*)\\n(?![\\n\\t ]))?/g, '$1$2') // more-indented lines aren't folded\n  //         ^ ind.line  ^ empty     ^ capture next empty lines only at end of indent\n  .replace(/\\n+/g, `$&${indent}`);\n  const body = foldFlowLines(`${wsStart}${value}${wsEnd}`, indent, FOLD_BLOCK, strOptions.fold);\n  return `${header}\\n${indent}${body}`;\n}\n\nfunction plainString(item, ctx, onComment, onChompKeep) {\n  const {\n    comment,\n    type,\n    value\n  } = item;\n  const {\n    actualString,\n    implicitKey,\n    indent,\n    inFlow\n  } = ctx;\n\n  if (implicitKey && /[\\n[\\]{},]/.test(value) || inFlow && /[[\\]{},]/.test(value)) {\n    return doubleQuotedString(value, ctx);\n  }\n\n  if (!value || /^[\\n\\t ,[\\]{}#&*!|>'\"%@`]|^[?-]$|^[?-][ \\t]|[\\n:][ \\t]|[ \\t]\\n|[\\n\\t ]#|[\\n\\t :]$/.test(value)) {\n    // not allowed:\n    // - empty string, '-' or '?'\n    // - start with an indicator character (except [?:-]) or /[?-] /\n    // - '\\n ', ': ' or ' \\n' anywhere\n    // - '#' not preceded by a non-space char\n    // - end with ' ' or ':'\n    return implicitKey || inFlow || value.indexOf('\\n') === -1 ? value.indexOf('\"') !== -1 && value.indexOf(\"'\") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  if (!implicitKey && !inFlow && type !== PlainValue.Type.PLAIN && value.indexOf('\\n') !== -1) {\n    // Where allowed & type not set explicitly, prefer block style for multiline strings\n    return blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  if (indent === '' && containsDocumentMarker(value)) {\n    ctx.forceBlockIndent = true;\n    return blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  const str = value.replace(/\\n+/g, `$&\\n${indent}`); // Verify that output will be parsed as a string, as e.g. plain numbers and\n  // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),\n  // and others in v1.1.\n\n  if (actualString) {\n    const {\n      tags\n    } = ctx.doc.schema;\n    const resolved = resolveScalar(str, tags, tags.scalarFallback).value;\n    if (typeof resolved !== 'string') return doubleQuotedString(value, ctx);\n  }\n\n  const body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));\n\n  if (comment && !inFlow && (body.indexOf('\\n') !== -1 || comment.indexOf('\\n') !== -1)) {\n    if (onComment) onComment();\n    return addCommentBefore(body, indent, comment);\n  }\n\n  return body;\n}\n\nfunction stringifyString(item, ctx, onComment, onChompKeep) {\n  const {\n    defaultType\n  } = strOptions;\n  const {\n    implicitKey,\n    inFlow\n  } = ctx;\n  let {\n    type,\n    value\n  } = item;\n\n  if (typeof value !== 'string') {\n    value = String(value);\n    item = Object.assign({}, item, {\n      value\n    });\n  }\n\n  const _stringify = _type => {\n    switch (_type) {\n      case PlainValue.Type.BLOCK_FOLDED:\n      case PlainValue.Type.BLOCK_LITERAL:\n        return blockString(item, ctx, onComment, onChompKeep);\n\n      case PlainValue.Type.QUOTE_DOUBLE:\n        return doubleQuotedString(value, ctx);\n\n      case PlainValue.Type.QUOTE_SINGLE:\n        return singleQuotedString(value, ctx);\n\n      case PlainValue.Type.PLAIN:\n        return plainString(item, ctx, onComment, onChompKeep);\n\n      default:\n        return null;\n    }\n  };\n\n  if (type !== PlainValue.Type.QUOTE_DOUBLE && /[\\x00-\\x08\\x0b-\\x1f\\x7f-\\x9f]/.test(value)) {\n    // force double quotes on control characters\n    type = PlainValue.Type.QUOTE_DOUBLE;\n  } else if ((implicitKey || inFlow) && (type === PlainValue.Type.BLOCK_FOLDED || type === PlainValue.Type.BLOCK_LITERAL)) {\n    // should not happen; blocks are not valid inside flow containers\n    type = PlainValue.Type.QUOTE_DOUBLE;\n  }\n\n  let res = _stringify(type);\n\n  if (res === null) {\n    res = _stringify(defaultType);\n    if (res === null) throw new Error(`Unsupported default string type ${defaultType}`);\n  }\n\n  return res;\n}\n\nfunction stringifyNumber({\n  format,\n  minFractionDigits,\n  tag,\n  value\n}) {\n  if (typeof value === 'bigint') return String(value);\n  if (!isFinite(value)) return isNaN(value) ? '.nan' : value < 0 ? '-.inf' : '.inf';\n  let n = JSON.stringify(value);\n\n  if (!format && minFractionDigits && (!tag || tag === 'tag:yaml.org,2002:float') && /^\\d/.test(n)) {\n    let i = n.indexOf('.');\n\n    if (i < 0) {\n      i = n.length;\n      n += '.';\n    }\n\n    let d = minFractionDigits - (n.length - i - 1);\n\n    while (d-- > 0) n += '0';\n  }\n\n  return n;\n}\n\nfunction checkFlowCollectionEnd(errors, cst) {\n  let char, name;\n\n  switch (cst.type) {\n    case PlainValue.Type.FLOW_MAP:\n      char = '}';\n      name = 'flow map';\n      break;\n\n    case PlainValue.Type.FLOW_SEQ:\n      char = ']';\n      name = 'flow sequence';\n      break;\n\n    default:\n      errors.push(new PlainValue.YAMLSemanticError(cst, 'Not a flow collection!?'));\n      return;\n  }\n\n  let lastItem;\n\n  for (let i = cst.items.length - 1; i >= 0; --i) {\n    const item = cst.items[i];\n\n    if (!item || item.type !== PlainValue.Type.COMMENT) {\n      lastItem = item;\n      break;\n    }\n  }\n\n  if (lastItem && lastItem.char !== char) {\n    const msg = `Expected ${name} to end with ${char}`;\n    let err;\n\n    if (typeof lastItem.offset === 'number') {\n      err = new PlainValue.YAMLSemanticError(cst, msg);\n      err.offset = lastItem.offset + 1;\n    } else {\n      err = new PlainValue.YAMLSemanticError(lastItem, msg);\n      if (lastItem.range && lastItem.range.end) err.offset = lastItem.range.end - lastItem.range.start;\n    }\n\n    errors.push(err);\n  }\n}\nfunction checkFlowCommentSpace(errors, comment) {\n  const prev = comment.context.src[comment.range.start - 1];\n\n  if (prev !== '\\n' && prev !== '\\t' && prev !== ' ') {\n    const msg = 'Comments must be separated from other tokens by white space characters';\n    errors.push(new PlainValue.YAMLSemanticError(comment, msg));\n  }\n}\nfunction getLongKeyError(source, key) {\n  const sk = String(key);\n  const k = sk.substr(0, 8) + '...' + sk.substr(-8);\n  return new PlainValue.YAMLSemanticError(source, `The \"${k}\" key is too long`);\n}\nfunction resolveComments(collection, comments) {\n  for (const {\n    afterKey,\n    before,\n    comment\n  } of comments) {\n    let item = collection.items[before];\n\n    if (!item) {\n      if (comment !== undefined) {\n        if (collection.comment) collection.comment += '\\n' + comment;else collection.comment = comment;\n      }\n    } else {\n      if (afterKey && item.value) item = item.value;\n\n      if (comment === undefined) {\n        if (afterKey || !item.commentBefore) item.spaceBefore = true;\n      } else {\n        if (item.commentBefore) item.commentBefore += '\\n' + comment;else item.commentBefore = comment;\n      }\n    }\n  }\n}\n\n// on error, will return { str: string, errors: Error[] }\nfunction resolveString(doc, node) {\n  const res = node.strValue;\n  if (!res) return '';\n  if (typeof res === 'string') return res;\n  res.errors.forEach(error => {\n    if (!error.source) error.source = node;\n    doc.errors.push(error);\n  });\n  return res.str;\n}\n\nfunction resolveTagHandle(doc, node) {\n  const {\n    handle,\n    suffix\n  } = node.tag;\n  let prefix = doc.tagPrefixes.find(p => p.handle === handle);\n\n  if (!prefix) {\n    const dtp = doc.getDefaults().tagPrefixes;\n    if (dtp) prefix = dtp.find(p => p.handle === handle);\n    if (!prefix) throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag handle is non-default and was not declared.`);\n  }\n\n  if (!suffix) throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag has no suffix.`);\n\n  if (handle === '!' && (doc.version || doc.options.version) === '1.0') {\n    if (suffix[0] === '^') {\n      doc.warnings.push(new PlainValue.YAMLWarning(node, 'YAML 1.0 ^ tag expansion is not supported'));\n      return suffix;\n    }\n\n    if (/[:/]/.test(suffix)) {\n      // word/foo -> tag:word.yaml.org,2002:foo\n      const vocab = suffix.match(/^([a-z0-9-]+)\\/(.*)/i);\n      return vocab ? `tag:${vocab[1]}.yaml.org,2002:${vocab[2]}` : `tag:${suffix}`;\n    }\n  }\n\n  return prefix.prefix + decodeURIComponent(suffix);\n}\n\nfunction resolveTagName(doc, node) {\n  const {\n    tag,\n    type\n  } = node;\n  let nonSpecific = false;\n\n  if (tag) {\n    const {\n      handle,\n      suffix,\n      verbatim\n    } = tag;\n\n    if (verbatim) {\n      if (verbatim !== '!' && verbatim !== '!!') return verbatim;\n      const msg = `Verbatim tags aren't resolved, so ${verbatim} is invalid.`;\n      doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));\n    } else if (handle === '!' && !suffix) {\n      nonSpecific = true;\n    } else {\n      try {\n        return resolveTagHandle(doc, node);\n      } catch (error) {\n        doc.errors.push(error);\n      }\n    }\n  }\n\n  switch (type) {\n    case PlainValue.Type.BLOCK_FOLDED:\n    case PlainValue.Type.BLOCK_LITERAL:\n    case PlainValue.Type.QUOTE_DOUBLE:\n    case PlainValue.Type.QUOTE_SINGLE:\n      return PlainValue.defaultTags.STR;\n\n    case PlainValue.Type.FLOW_MAP:\n    case PlainValue.Type.MAP:\n      return PlainValue.defaultTags.MAP;\n\n    case PlainValue.Type.FLOW_SEQ:\n    case PlainValue.Type.SEQ:\n      return PlainValue.defaultTags.SEQ;\n\n    case PlainValue.Type.PLAIN:\n      return nonSpecific ? PlainValue.defaultTags.STR : null;\n\n    default:\n      return null;\n  }\n}\n\nfunction resolveByTagName(doc, node, tagName) {\n  const {\n    tags\n  } = doc.schema;\n  const matchWithTest = [];\n\n  for (const tag of tags) {\n    if (tag.tag === tagName) {\n      if (tag.test) matchWithTest.push(tag);else {\n        const res = tag.resolve(doc, node);\n        return res instanceof Collection ? res : new Scalar(res);\n      }\n    }\n  }\n\n  const str = resolveString(doc, node);\n  if (typeof str === 'string' && matchWithTest.length > 0) return resolveScalar(str, matchWithTest, tags.scalarFallback);\n  return null;\n}\n\nfunction getFallbackTagName({\n  type\n}) {\n  switch (type) {\n    case PlainValue.Type.FLOW_MAP:\n    case PlainValue.Type.MAP:\n      return PlainValue.defaultTags.MAP;\n\n    case PlainValue.Type.FLOW_SEQ:\n    case PlainValue.Type.SEQ:\n      return PlainValue.defaultTags.SEQ;\n\n    default:\n      return PlainValue.defaultTags.STR;\n  }\n}\n\nfunction resolveTag(doc, node, tagName) {\n  try {\n    const res = resolveByTagName(doc, node, tagName);\n\n    if (res) {\n      if (tagName && node.tag) res.tag = tagName;\n      return res;\n    }\n  } catch (error) {\n    /* istanbul ignore if */\n    if (!error.source) error.source = node;\n    doc.errors.push(error);\n    return null;\n  }\n\n  try {\n    const fallback = getFallbackTagName(node);\n    if (!fallback) throw new Error(`The tag ${tagName} is unavailable`);\n    const msg = `The tag ${tagName} is unavailable, falling back to ${fallback}`;\n    doc.warnings.push(new PlainValue.YAMLWarning(node, msg));\n    const res = resolveByTagName(doc, node, fallback);\n    res.tag = tagName;\n    return res;\n  } catch (error) {\n    const refError = new PlainValue.YAMLReferenceError(node, error.message);\n    refError.stack = error.stack;\n    doc.errors.push(refError);\n    return null;\n  }\n}\n\nconst isCollectionItem = node => {\n  if (!node) return false;\n  const {\n    type\n  } = node;\n  return type === PlainValue.Type.MAP_KEY || type === PlainValue.Type.MAP_VALUE || type === PlainValue.Type.SEQ_ITEM;\n};\n\nfunction resolveNodeProps(errors, node) {\n  const comments = {\n    before: [],\n    after: []\n  };\n  let hasAnchor = false;\n  let hasTag = false;\n  const props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;\n\n  for (const {\n    start,\n    end\n  } of props) {\n    switch (node.context.src[start]) {\n      case PlainValue.Char.COMMENT:\n        {\n          if (!node.commentHasRequiredWhitespace(start)) {\n            const msg = 'Comments must be separated from other tokens by white space characters';\n            errors.push(new PlainValue.YAMLSemanticError(node, msg));\n          }\n\n          const {\n            header,\n            valueRange\n          } = node;\n          const cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;\n          cc.push(node.context.src.slice(start + 1, end));\n          break;\n        }\n      // Actual anchor & tag resolution is handled by schema, here we just complain\n\n      case PlainValue.Char.ANCHOR:\n        if (hasAnchor) {\n          const msg = 'A node can have at most one anchor';\n          errors.push(new PlainValue.YAMLSemanticError(node, msg));\n        }\n\n        hasAnchor = true;\n        break;\n\n      case PlainValue.Char.TAG:\n        if (hasTag) {\n          const msg = 'A node can have at most one tag';\n          errors.push(new PlainValue.YAMLSemanticError(node, msg));\n        }\n\n        hasTag = true;\n        break;\n    }\n  }\n\n  return {\n    comments,\n    hasAnchor,\n    hasTag\n  };\n}\n\nfunction resolveNodeValue(doc, node) {\n  const {\n    anchors,\n    errors,\n    schema\n  } = doc;\n\n  if (node.type === PlainValue.Type.ALIAS) {\n    const name = node.rawValue;\n    const src = anchors.getNode(name);\n\n    if (!src) {\n      const msg = `Aliased anchor not found: ${name}`;\n      errors.push(new PlainValue.YAMLReferenceError(node, msg));\n      return null;\n    } // Lazy resolution for circular references\n\n\n    const res = new Alias(src);\n\n    anchors._cstAliases.push(res);\n\n    return res;\n  }\n\n  const tagName = resolveTagName(doc, node);\n  if (tagName) return resolveTag(doc, node, tagName);\n\n  if (node.type !== PlainValue.Type.PLAIN) {\n    const msg = `Failed to resolve ${node.type} node here`;\n    errors.push(new PlainValue.YAMLSyntaxError(node, msg));\n    return null;\n  }\n\n  try {\n    const str = resolveString(doc, node);\n    return resolveScalar(str, schema.tags, schema.tags.scalarFallback);\n  } catch (error) {\n    if (!error.source) error.source = node;\n    errors.push(error);\n    return null;\n  }\n} // sets node.resolved on success\n\n\nfunction resolveNode(doc, node) {\n  if (!node) return null;\n  if (node.error) doc.errors.push(node.error);\n  const {\n    comments,\n    hasAnchor,\n    hasTag\n  } = resolveNodeProps(doc.errors, node);\n\n  if (hasAnchor) {\n    const {\n      anchors\n    } = doc;\n    const name = node.anchor;\n    const prev = anchors.getNode(name); // At this point, aliases for any preceding node with the same anchor\n    // name have already been resolved, so it may safely be renamed.\n\n    if (prev) anchors.map[anchors.newName(name)] = prev; // During parsing, we need to store the CST node in anchors.map as\n    // anchors need to be available during resolution to allow for\n    // circular references.\n\n    anchors.map[name] = node;\n  }\n\n  if (node.type === PlainValue.Type.ALIAS && (hasAnchor || hasTag)) {\n    const msg = 'An alias node must not specify any properties';\n    doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));\n  }\n\n  const res = resolveNodeValue(doc, node);\n\n  if (res) {\n    res.range = [node.range.start, node.range.end];\n    if (doc.options.keepCstNodes) res.cstNode = node;\n    if (doc.options.keepNodeTypes) res.type = node.type;\n    const cb = comments.before.join('\\n');\n\n    if (cb) {\n      res.commentBefore = res.commentBefore ? `${res.commentBefore}\\n${cb}` : cb;\n    }\n\n    const ca = comments.after.join('\\n');\n    if (ca) res.comment = res.comment ? `${res.comment}\\n${ca}` : ca;\n  }\n\n  return node.resolved = res;\n}\n\nfunction resolveMap(doc, cst) {\n  if (cst.type !== PlainValue.Type.MAP && cst.type !== PlainValue.Type.FLOW_MAP) {\n    const msg = `A ${cst.type} node cannot be resolved as a mapping`;\n    doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));\n    return null;\n  }\n\n  const {\n    comments,\n    items\n  } = cst.type === PlainValue.Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst);\n  const map = new YAMLMap();\n  map.items = items;\n  resolveComments(map, comments);\n  let hasCollectionKey = false;\n\n  for (let i = 0; i < items.length; ++i) {\n    const {\n      key: iKey\n    } = items[i];\n    if (iKey instanceof Collection) hasCollectionKey = true;\n\n    if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {\n      items[i] = new Merge(items[i]);\n      const sources = items[i].value.items;\n      let error = null;\n      sources.some(node => {\n        if (node instanceof Alias) {\n          // During parsing, alias sources are CST nodes; to account for\n          // circular references their resolved values can't be used here.\n          const {\n            type\n          } = node.source;\n          if (type === PlainValue.Type.MAP || type === PlainValue.Type.FLOW_MAP) return false;\n          return error = 'Merge nodes aliases can only point to maps';\n        }\n\n        return error = 'Merge nodes can only have Alias nodes as values';\n      });\n      if (error) doc.errors.push(new PlainValue.YAMLSemanticError(cst, error));\n    } else {\n      for (let j = i + 1; j < items.length; ++j) {\n        const {\n          key: jKey\n        } = items[j];\n\n        if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, 'value') && iKey.value === jKey.value) {\n          const msg = `Map keys must be unique; \"${iKey}\" is repeated`;\n          doc.errors.push(new PlainValue.YAMLSemanticError(cst, msg));\n          break;\n        }\n      }\n    }\n  }\n\n  if (hasCollectionKey && !doc.options.mapAsMap) {\n    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';\n    doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));\n  }\n\n  cst.resolved = map;\n  return map;\n}\n\nconst valueHasPairComment = ({\n  context: {\n    lineStart,\n    node,\n    src\n  },\n  props\n}) => {\n  if (props.length === 0) return false;\n  const {\n    start\n  } = props[0];\n  if (node && start > node.valueRange.start) return false;\n  if (src[start] !== PlainValue.Char.COMMENT) return false;\n\n  for (let i = lineStart; i < start; ++i) if (src[i] === '\\n') return false;\n\n  return true;\n};\n\nfunction resolvePairComment(item, pair) {\n  if (!valueHasPairComment(item)) return;\n  const comment = item.getPropValue(0, PlainValue.Char.COMMENT, true);\n  let found = false;\n  const cb = pair.value.commentBefore;\n\n  if (cb && cb.startsWith(comment)) {\n    pair.value.commentBefore = cb.substr(comment.length + 1);\n    found = true;\n  } else {\n    const cc = pair.value.comment;\n\n    if (!item.node && cc && cc.startsWith(comment)) {\n      pair.value.comment = cc.substr(comment.length + 1);\n      found = true;\n    }\n  }\n\n  if (found) pair.comment = comment;\n}\n\nfunction resolveBlockMapItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let key = undefined;\n  let keyStart = null;\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    switch (item.type) {\n      case PlainValue.Type.BLANK_LINE:\n        comments.push({\n          afterKey: !!key,\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.COMMENT:\n        comments.push({\n          afterKey: !!key,\n          before: items.length,\n          comment: item.comment\n        });\n        break;\n\n      case PlainValue.Type.MAP_KEY:\n        if (key !== undefined) items.push(new Pair(key));\n        if (item.error) doc.errors.push(item.error);\n        key = resolveNode(doc, item.node);\n        keyStart = null;\n        break;\n\n      case PlainValue.Type.MAP_VALUE:\n        {\n          if (key === undefined) key = null;\n          if (item.error) doc.errors.push(item.error);\n\n          if (!item.context.atLineStart && item.node && item.node.type === PlainValue.Type.MAP && !item.node.context.atLineStart) {\n            const msg = 'Nested mappings are not allowed in compact mappings';\n            doc.errors.push(new PlainValue.YAMLSemanticError(item.node, msg));\n          }\n\n          let valueNode = item.node;\n\n          if (!valueNode && item.props.length > 0) {\n            // Comments on an empty mapping value need to be preserved, so we\n            // need to construct a minimal empty node here to use instead of the\n            // missing `item.node`. -- eemeli/yaml#19\n            valueNode = new PlainValue.PlainValue(PlainValue.Type.PLAIN, []);\n            valueNode.context = {\n              parent: item,\n              src: item.context.src\n            };\n            const pos = item.range.start + 1;\n            valueNode.range = {\n              start: pos,\n              end: pos\n            };\n            valueNode.valueRange = {\n              start: pos,\n              end: pos\n            };\n\n            if (typeof item.range.origStart === 'number') {\n              const origPos = item.range.origStart + 1;\n              valueNode.range.origStart = valueNode.range.origEnd = origPos;\n              valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;\n            }\n          }\n\n          const pair = new Pair(key, resolveNode(doc, valueNode));\n          resolvePairComment(item, pair);\n          items.push(pair);\n\n          if (key && typeof keyStart === 'number') {\n            if (item.range.start > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n          }\n\n          key = undefined;\n          keyStart = null;\n        }\n        break;\n\n      default:\n        if (key !== undefined) items.push(new Pair(key));\n        key = resolveNode(doc, item);\n        keyStart = item.range.start;\n        if (item.error) doc.errors.push(item.error);\n\n        next: for (let j = i + 1;; ++j) {\n          const nextItem = cst.items[j];\n\n          switch (nextItem && nextItem.type) {\n            case PlainValue.Type.BLANK_LINE:\n            case PlainValue.Type.COMMENT:\n              continue next;\n\n            case PlainValue.Type.MAP_VALUE:\n              break next;\n\n            default:\n              {\n                const msg = 'Implicit map keys need to be followed by map values';\n                doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n                break next;\n              }\n          }\n        }\n\n        if (item.valueRangeContainsNewline) {\n          const msg = 'Implicit map keys need to be on a single line';\n          doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n        }\n\n    }\n  }\n\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveFlowMapItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let key = undefined;\n  let explicitKey = false;\n  let next = '{';\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    if (typeof item.char === 'string') {\n      const {\n        char,\n        offset\n      } = item;\n\n      if (char === '?' && key === undefined && !explicitKey) {\n        explicitKey = true;\n        next = ':';\n        continue;\n      }\n\n      if (char === ':') {\n        if (key === undefined) key = null;\n\n        if (next === ':') {\n          next = ',';\n          continue;\n        }\n      } else {\n        if (explicitKey) {\n          if (key === undefined && char !== ',') key = null;\n          explicitKey = false;\n        }\n\n        if (key !== undefined) {\n          items.push(new Pair(key));\n          key = undefined;\n\n          if (char === ',') {\n            next = ':';\n            continue;\n          }\n        }\n      }\n\n      if (char === '}') {\n        if (i === cst.items.length - 1) continue;\n      } else if (char === next) {\n        next = ':';\n        continue;\n      }\n\n      const msg = `Flow map contains an unexpected ${char}`;\n      const err = new PlainValue.YAMLSyntaxError(cst, msg);\n      err.offset = offset;\n      doc.errors.push(err);\n    } else if (item.type === PlainValue.Type.BLANK_LINE) {\n      comments.push({\n        afterKey: !!key,\n        before: items.length\n      });\n    } else if (item.type === PlainValue.Type.COMMENT) {\n      checkFlowCommentSpace(doc.errors, item);\n      comments.push({\n        afterKey: !!key,\n        before: items.length,\n        comment: item.comment\n      });\n    } else if (key === undefined) {\n      if (next === ',') doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Separator , missing in flow map'));\n      key = resolveNode(doc, item);\n    } else {\n      if (next !== ',') doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Indicator : missing in flow map entry'));\n      items.push(new Pair(key, resolveNode(doc, item)));\n      key = undefined;\n      explicitKey = false;\n    }\n  }\n\n  checkFlowCollectionEnd(doc.errors, cst);\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveSeq(doc, cst) {\n  if (cst.type !== PlainValue.Type.SEQ && cst.type !== PlainValue.Type.FLOW_SEQ) {\n    const msg = `A ${cst.type} node cannot be resolved as a sequence`;\n    doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));\n    return null;\n  }\n\n  const {\n    comments,\n    items\n  } = cst.type === PlainValue.Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst);\n  const seq = new YAMLSeq();\n  seq.items = items;\n  resolveComments(seq, comments);\n\n  if (!doc.options.mapAsMap && items.some(it => it instanceof Pair && it.key instanceof Collection)) {\n    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';\n    doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));\n  }\n\n  cst.resolved = seq;\n  return seq;\n}\n\nfunction resolveBlockSeqItems(doc, cst) {\n  const comments = [];\n  const items = [];\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    switch (item.type) {\n      case PlainValue.Type.BLANK_LINE:\n        comments.push({\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.COMMENT:\n        comments.push({\n          comment: item.comment,\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.SEQ_ITEM:\n        if (item.error) doc.errors.push(item.error);\n        items.push(resolveNode(doc, item.node));\n\n        if (item.hasProps) {\n          const msg = 'Sequence items cannot have tags or anchors before the - indicator';\n          doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n        }\n\n        break;\n\n      default:\n        if (item.error) doc.errors.push(item.error);\n        doc.errors.push(new PlainValue.YAMLSyntaxError(item, `Unexpected ${item.type} node in sequence`));\n    }\n  }\n\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveFlowSeqItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let explicitKey = false;\n  let key = undefined;\n  let keyStart = null;\n  let next = '[';\n  let prevItem = null;\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    if (typeof item.char === 'string') {\n      const {\n        char,\n        offset\n      } = item;\n\n      if (char !== ':' && (explicitKey || key !== undefined)) {\n        if (explicitKey && key === undefined) key = next ? items.pop() : null;\n        items.push(new Pair(key));\n        explicitKey = false;\n        key = undefined;\n        keyStart = null;\n      }\n\n      if (char === next) {\n        next = null;\n      } else if (!next && char === '?') {\n        explicitKey = true;\n      } else if (next !== '[' && char === ':' && key === undefined) {\n        if (next === ',') {\n          key = items.pop();\n\n          if (key instanceof Pair) {\n            const msg = 'Chaining flow sequence pairs is invalid';\n            const err = new PlainValue.YAMLSemanticError(cst, msg);\n            err.offset = offset;\n            doc.errors.push(err);\n          }\n\n          if (!explicitKey && typeof keyStart === 'number') {\n            const keyEnd = item.range ? item.range.start : item.offset;\n            if (keyEnd > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n            const {\n              src\n            } = prevItem.context;\n\n            for (let i = keyStart; i < keyEnd; ++i) if (src[i] === '\\n') {\n              const msg = 'Implicit keys of flow sequence pairs need to be on a single line';\n              doc.errors.push(new PlainValue.YAMLSemanticError(prevItem, msg));\n              break;\n            }\n          }\n        } else {\n          key = null;\n        }\n\n        keyStart = null;\n        explicitKey = false;\n        next = null;\n      } else if (next === '[' || char !== ']' || i < cst.items.length - 1) {\n        const msg = `Flow sequence contains an unexpected ${char}`;\n        const err = new PlainValue.YAMLSyntaxError(cst, msg);\n        err.offset = offset;\n        doc.errors.push(err);\n      }\n    } else if (item.type === PlainValue.Type.BLANK_LINE) {\n      comments.push({\n        before: items.length\n      });\n    } else if (item.type === PlainValue.Type.COMMENT) {\n      checkFlowCommentSpace(doc.errors, item);\n      comments.push({\n        comment: item.comment,\n        before: items.length\n      });\n    } else {\n      if (next) {\n        const msg = `Expected a ${next} in flow sequence`;\n        doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n      }\n\n      const value = resolveNode(doc, item);\n\n      if (key === undefined) {\n        items.push(value);\n        prevItem = item;\n      } else {\n        items.push(new Pair(key, value));\n        key = undefined;\n      }\n\n      keyStart = item.range.start;\n      next = ',';\n    }\n  }\n\n  checkFlowCollectionEnd(doc.errors, cst);\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nexports.Alias = Alias;\nexports.Collection = Collection;\nexports.Merge = Merge;\nexports.Node = Node;\nexports.Pair = Pair;\nexports.Scalar = Scalar;\nexports.YAMLMap = YAMLMap;\nexports.YAMLSeq = YAMLSeq;\nexports.addComment = addComment;\nexports.binaryOptions = binaryOptions;\nexports.boolOptions = boolOptions;\nexports.findPair = findPair;\nexports.intOptions = intOptions;\nexports.isEmptyPath = isEmptyPath;\nexports.nullOptions = nullOptions;\nexports.resolveMap = resolveMap;\nexports.resolveNode = resolveNode;\nexports.resolveSeq = resolveSeq;\nexports.resolveString = resolveString;\nexports.strOptions = strOptions;\nexports.stringifyNumber = stringifyNumber;\nexports.stringifyString = stringifyString;\nexports.toJSON = toJSON;\n", "'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar resolveSeq = require('./resolveSeq-d03cb037.js');\n\n/* global atob, btoa, Buffer */\nconst binary = {\n  identify: value => value instanceof Uint8Array,\n  // Buffer inherits from Uint8Array\n  default: false,\n  tag: 'tag:yaml.org,2002:binary',\n\n  /**\n   * Returns a Buffer in node and an Uint8Array in browsers\n   *\n   * To use the resulting buffer as an image, you'll want to do something like:\n   *\n   *   const blob = new Blob([buffer], { type: 'image/jpeg' })\n   *   document.querySelector('#photo').src = URL.createObjectURL(blob)\n   */\n  resolve: (doc, node) => {\n    const src = resolveSeq.resolveString(doc, node);\n\n    if (typeof Buffer === 'function') {\n      return Buffer.from(src, 'base64');\n    } else if (typeof atob === 'function') {\n      // On IE 11, atob() can't handle newlines\n      const str = atob(src.replace(/[\\n\\r]/g, ''));\n      const buffer = new Uint8Array(str.length);\n\n      for (let i = 0; i < str.length; ++i) buffer[i] = str.charCodeAt(i);\n\n      return buffer;\n    } else {\n      const msg = 'This environment does not support reading binary tags; either Buffer or atob is required';\n      doc.errors.push(new PlainValue.YAMLReferenceError(node, msg));\n      return null;\n    }\n  },\n  options: resolveSeq.binaryOptions,\n  stringify: ({\n    comment,\n    type,\n    value\n  }, ctx, onComment, onChompKeep) => {\n    let src;\n\n    if (typeof Buffer === 'function') {\n      src = value instanceof Buffer ? value.toString('base64') : Buffer.from(value.buffer).toString('base64');\n    } else if (typeof btoa === 'function') {\n      let s = '';\n\n      for (let i = 0; i < value.length; ++i) s += String.fromCharCode(value[i]);\n\n      src = btoa(s);\n    } else {\n      throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');\n    }\n\n    if (!type) type = resolveSeq.binaryOptions.defaultType;\n\n    if (type === PlainValue.Type.QUOTE_DOUBLE) {\n      value = src;\n    } else {\n      const {\n        lineWidth\n      } = resolveSeq.binaryOptions;\n      const n = Math.ceil(src.length / lineWidth);\n      const lines = new Array(n);\n\n      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {\n        lines[i] = src.substr(o, lineWidth);\n      }\n\n      value = lines.join(type === PlainValue.Type.BLOCK_LITERAL ? '\\n' : ' ');\n    }\n\n    return resolveSeq.stringifyString({\n      comment,\n      type,\n      value\n    }, ctx, onComment, onChompKeep);\n  }\n};\n\nfunction parsePairs(doc, cst) {\n  const seq = resolveSeq.resolveSeq(doc, cst);\n\n  for (let i = 0; i < seq.items.length; ++i) {\n    let item = seq.items[i];\n    if (item instanceof resolveSeq.Pair) continue;else if (item instanceof resolveSeq.YAMLMap) {\n      if (item.items.length > 1) {\n        const msg = 'Each pair must have its own sequence indicator';\n        throw new PlainValue.YAMLSemanticError(cst, msg);\n      }\n\n      const pair = item.items[0] || new resolveSeq.Pair();\n      if (item.commentBefore) pair.commentBefore = pair.commentBefore ? `${item.commentBefore}\\n${pair.commentBefore}` : item.commentBefore;\n      if (item.comment) pair.comment = pair.comment ? `${item.comment}\\n${pair.comment}` : item.comment;\n      item = pair;\n    }\n    seq.items[i] = item instanceof resolveSeq.Pair ? item : new resolveSeq.Pair(item);\n  }\n\n  return seq;\n}\nfunction createPairs(schema, iterable, ctx) {\n  const pairs = new resolveSeq.YAMLSeq(schema);\n  pairs.tag = 'tag:yaml.org,2002:pairs';\n\n  for (const it of iterable) {\n    let key, value;\n\n    if (Array.isArray(it)) {\n      if (it.length === 2) {\n        key = it[0];\n        value = it[1];\n      } else throw new TypeError(`Expected [key, value] tuple: ${it}`);\n    } else if (it && it instanceof Object) {\n      const keys = Object.keys(it);\n\n      if (keys.length === 1) {\n        key = keys[0];\n        value = it[key];\n      } else throw new TypeError(`Expected { key: value } tuple: ${it}`);\n    } else {\n      key = it;\n    }\n\n    const pair = schema.createPair(key, value, ctx);\n    pairs.items.push(pair);\n  }\n\n  return pairs;\n}\nconst pairs = {\n  default: false,\n  tag: 'tag:yaml.org,2002:pairs',\n  resolve: parsePairs,\n  createNode: createPairs\n};\n\nclass YAMLOMap extends resolveSeq.YAMLSeq {\n  constructor() {\n    super();\n\n    PlainValue._defineProperty(this, \"add\", resolveSeq.YAMLMap.prototype.add.bind(this));\n\n    PlainValue._defineProperty(this, \"delete\", resolveSeq.YAMLMap.prototype.delete.bind(this));\n\n    PlainValue._defineProperty(this, \"get\", resolveSeq.YAMLMap.prototype.get.bind(this));\n\n    PlainValue._defineProperty(this, \"has\", resolveSeq.YAMLMap.prototype.has.bind(this));\n\n    PlainValue._defineProperty(this, \"set\", resolveSeq.YAMLMap.prototype.set.bind(this));\n\n    this.tag = YAMLOMap.tag;\n  }\n\n  toJSON(_, ctx) {\n    const map = new Map();\n    if (ctx && ctx.onCreate) ctx.onCreate(map);\n\n    for (const pair of this.items) {\n      let key, value;\n\n      if (pair instanceof resolveSeq.Pair) {\n        key = resolveSeq.toJSON(pair.key, '', ctx);\n        value = resolveSeq.toJSON(pair.value, key, ctx);\n      } else {\n        key = resolveSeq.toJSON(pair, '', ctx);\n      }\n\n      if (map.has(key)) throw new Error('Ordered maps must not include duplicate keys');\n      map.set(key, value);\n    }\n\n    return map;\n  }\n\n}\n\nPlainValue._defineProperty(YAMLOMap, \"tag\", 'tag:yaml.org,2002:omap');\n\nfunction parseOMap(doc, cst) {\n  const pairs = parsePairs(doc, cst);\n  const seenKeys = [];\n\n  for (const {\n    key\n  } of pairs.items) {\n    if (key instanceof resolveSeq.Scalar) {\n      if (seenKeys.includes(key.value)) {\n        const msg = 'Ordered maps must not include duplicate keys';\n        throw new PlainValue.YAMLSemanticError(cst, msg);\n      } else {\n        seenKeys.push(key.value);\n      }\n    }\n  }\n\n  return Object.assign(new YAMLOMap(), pairs);\n}\n\nfunction createOMap(schema, iterable, ctx) {\n  const pairs = createPairs(schema, iterable, ctx);\n  const omap = new YAMLOMap();\n  omap.items = pairs.items;\n  return omap;\n}\n\nconst omap = {\n  identify: value => value instanceof Map,\n  nodeClass: YAMLOMap,\n  default: false,\n  tag: 'tag:yaml.org,2002:omap',\n  resolve: parseOMap,\n  createNode: createOMap\n};\n\nclass YAMLSet extends resolveSeq.YAMLMap {\n  constructor() {\n    super();\n    this.tag = YAMLSet.tag;\n  }\n\n  add(key) {\n    const pair = key instanceof resolveSeq.Pair ? key : new resolveSeq.Pair(key);\n    const prev = resolveSeq.findPair(this.items, pair.key);\n    if (!prev) this.items.push(pair);\n  }\n\n  get(key, keepPair) {\n    const pair = resolveSeq.findPair(this.items, key);\n    return !keepPair && pair instanceof resolveSeq.Pair ? pair.key instanceof resolveSeq.Scalar ? pair.key.value : pair.key : pair;\n  }\n\n  set(key, value) {\n    if (typeof value !== 'boolean') throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);\n    const prev = resolveSeq.findPair(this.items, key);\n\n    if (prev && !value) {\n      this.items.splice(this.items.indexOf(prev), 1);\n    } else if (!prev && value) {\n      this.items.push(new resolveSeq.Pair(key));\n    }\n  }\n\n  toJSON(_, ctx) {\n    return super.toJSON(_, ctx, Set);\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx) return JSON.stringify(this);\n    if (this.hasAllNullValues()) return super.toString(ctx, onComment, onChompKeep);else throw new Error('Set items must all have null values');\n  }\n\n}\n\nPlainValue._defineProperty(YAMLSet, \"tag\", 'tag:yaml.org,2002:set');\n\nfunction parseSet(doc, cst) {\n  const map = resolveSeq.resolveMap(doc, cst);\n  if (!map.hasAllNullValues()) throw new PlainValue.YAMLSemanticError(cst, 'Set items must all have null values');\n  return Object.assign(new YAMLSet(), map);\n}\n\nfunction createSet(schema, iterable, ctx) {\n  const set = new YAMLSet();\n\n  for (const value of iterable) set.items.push(schema.createPair(value, null, ctx));\n\n  return set;\n}\n\nconst set = {\n  identify: value => value instanceof Set,\n  nodeClass: YAMLSet,\n  default: false,\n  tag: 'tag:yaml.org,2002:set',\n  resolve: parseSet,\n  createNode: createSet\n};\n\nconst parseSexagesimal = (sign, parts) => {\n  const n = parts.split(':').reduce((n, p) => n * 60 + Number(p), 0);\n  return sign === '-' ? -n : n;\n}; // hhhh:mm:ss.sss\n\n\nconst stringifySexagesimal = ({\n  value\n}) => {\n  if (isNaN(value) || !isFinite(value)) return resolveSeq.stringifyNumber(value);\n  let sign = '';\n\n  if (value < 0) {\n    sign = '-';\n    value = Math.abs(value);\n  }\n\n  const parts = [value % 60]; // seconds, including ms\n\n  if (value < 60) {\n    parts.unshift(0); // at least one : is required\n  } else {\n    value = Math.round((value - parts[0]) / 60);\n    parts.unshift(value % 60); // minutes\n\n    if (value >= 60) {\n      value = Math.round((value - parts[0]) / 60);\n      parts.unshift(value); // hours\n    }\n  }\n\n  return sign + parts.map(n => n < 10 ? '0' + String(n) : String(n)).join(':').replace(/000000\\d*$/, '') // % 60 may introduce error\n  ;\n};\n\nconst intTime = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'TIME',\n  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,\n  resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, '')),\n  stringify: stringifySexagesimal\n};\nconst floatTime = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'TIME',\n  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*)$/,\n  resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, '')),\n  stringify: stringifySexagesimal\n};\nconst timestamp = {\n  identify: value => value instanceof Date,\n  default: true,\n  tag: 'tag:yaml.org,2002:timestamp',\n  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part\n  // may be omitted altogether, resulting in a date format. In such a case, the time part is\n  // assumed to be 00:00:00Z (start of day, UTC).\n  test: RegExp('^(?:' + '([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd\n  '(?:(?:t|T|[ \\\\t]+)' + // t | T | whitespace\n  '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?\n  '(?:[ \\\\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30\n  ')?' + ')$'),\n  resolve: (str, year, month, day, hour, minute, second, millisec, tz) => {\n    if (millisec) millisec = (millisec + '00').substr(1, 3);\n    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);\n\n    if (tz && tz !== 'Z') {\n      let d = parseSexagesimal(tz[0], tz.slice(1));\n      if (Math.abs(d) < 30) d *= 60;\n      date -= 60000 * d;\n    }\n\n    return new Date(date);\n  },\n  stringify: ({\n    value\n  }) => value.toISOString().replace(/((T00:00)?:00)?\\.000Z$/, '')\n};\n\n/* global console, process, YAML_SILENCE_DEPRECATION_WARNINGS, YAML_SILENCE_WARNINGS */\nfunction shouldWarn(deprecation) {\n  const env = typeof process !== 'undefined' && process.env || {};\n\n  if (deprecation) {\n    if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== 'undefined') return !YAML_SILENCE_DEPRECATION_WARNINGS;\n    return !env.YAML_SILENCE_DEPRECATION_WARNINGS;\n  }\n\n  if (typeof YAML_SILENCE_WARNINGS !== 'undefined') return !YAML_SILENCE_WARNINGS;\n  return !env.YAML_SILENCE_WARNINGS;\n}\n\nfunction warn(warning, type) {\n  if (shouldWarn(false)) {\n    const emit = typeof process !== 'undefined' && process.emitWarning; // This will throw in Jest if `warning` is an Error instance due to\n    // https://github.com/facebook/jest/issues/2549\n\n    if (emit) emit(warning, type);else {\n      // eslint-disable-next-line no-console\n      console.warn(type ? `${type}: ${warning}` : warning);\n    }\n  }\n}\nfunction warnFileDeprecation(filename) {\n  if (shouldWarn(true)) {\n    const path = filename.replace(/.*yaml[/\\\\]/i, '').replace(/\\.js$/, '').replace(/\\\\/g, '/');\n    warn(`The endpoint 'yaml/${path}' will be removed in a future release.`, 'DeprecationWarning');\n  }\n}\nconst warned = {};\nfunction warnOptionDeprecation(name, alternative) {\n  if (!warned[name] && shouldWarn(true)) {\n    warned[name] = true;\n    let msg = `The option '${name}' will be removed in a future release`;\n    msg += alternative ? `, use '${alternative}' instead.` : '.';\n    warn(msg, 'DeprecationWarning');\n  }\n}\n\nexports.binary = binary;\nexports.floatTime = floatTime;\nexports.intTime = intTime;\nexports.omap = omap;\nexports.pairs = pairs;\nexports.set = set;\nexports.timestamp = timestamp;\nexports.warn = warn;\nexports.warnFileDeprecation = warnFileDeprecation;\nexports.warnOptionDeprecation = warnOptionDeprecation;\n", "'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar resolveSeq = require('./resolveSeq-d03cb037.js');\nvar warnings = require('./warnings-1000a372.js');\n\nfunction createMap(schema, obj, ctx) {\n  const map = new resolveSeq.YAMLMap(schema);\n\n  if (obj instanceof Map) {\n    for (const [key, value] of obj) map.items.push(schema.createPair(key, value, ctx));\n  } else if (obj && typeof obj === 'object') {\n    for (const key of Object.keys(obj)) map.items.push(schema.createPair(key, obj[key], ctx));\n  }\n\n  if (typeof schema.sortMapEntries === 'function') {\n    map.items.sort(schema.sortMapEntries);\n  }\n\n  return map;\n}\n\nconst map = {\n  createNode: createMap,\n  default: true,\n  nodeClass: resolveSeq.YAMLMap,\n  tag: 'tag:yaml.org,2002:map',\n  resolve: resolveSeq.resolveMap\n};\n\nfunction createSeq(schema, obj, ctx) {\n  const seq = new resolveSeq.YAMLSeq(schema);\n\n  if (obj && obj[Symbol.iterator]) {\n    for (const it of obj) {\n      const v = schema.createNode(it, ctx.wrapScalars, null, ctx);\n      seq.items.push(v);\n    }\n  }\n\n  return seq;\n}\n\nconst seq = {\n  createNode: createSeq,\n  default: true,\n  nodeClass: resolveSeq.YAMLSeq,\n  tag: 'tag:yaml.org,2002:seq',\n  resolve: resolveSeq.resolveSeq\n};\n\nconst string = {\n  identify: value => typeof value === 'string',\n  default: true,\n  tag: 'tag:yaml.org,2002:str',\n  resolve: resolveSeq.resolveString,\n\n  stringify(item, ctx, onComment, onChompKeep) {\n    ctx = Object.assign({\n      actualString: true\n    }, ctx);\n    return resolveSeq.stringifyString(item, ctx, onComment, onChompKeep);\n  },\n\n  options: resolveSeq.strOptions\n};\n\nconst failsafe = [map, seq, string];\n\n/* global BigInt */\n\nconst intIdentify$2 = value => typeof value === 'bigint' || Number.isInteger(value);\n\nconst intResolve$1 = (src, part, radix) => resolveSeq.intOptions.asBigInt ? BigInt(src) : parseInt(part, radix);\n\nfunction intStringify$1(node, radix, prefix) {\n  const {\n    value\n  } = node;\n  if (intIdentify$2(value) && value >= 0) return prefix + value.toString(radix);\n  return resolveSeq.stringifyNumber(node);\n}\n\nconst nullObj = {\n  identify: value => value == null,\n  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,\n  default: true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^(?:~|[Nn]ull|NULL)?$/,\n  resolve: () => null,\n  options: resolveSeq.nullOptions,\n  stringify: () => resolveSeq.nullOptions.nullStr\n};\nconst boolObj = {\n  identify: value => typeof value === 'boolean',\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,\n  resolve: str => str[0] === 't' || str[0] === 'T',\n  options: resolveSeq.boolOptions,\n  stringify: ({\n    value\n  }) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr\n};\nconst octObj = {\n  identify: value => intIdentify$2(value) && value >= 0,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'OCT',\n  test: /^0o([0-7]+)$/,\n  resolve: (str, oct) => intResolve$1(str, oct, 8),\n  options: resolveSeq.intOptions,\n  stringify: node => intStringify$1(node, 8, '0o')\n};\nconst intObj = {\n  identify: intIdentify$2,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^[-+]?[0-9]+$/,\n  resolve: str => intResolve$1(str, str, 10),\n  options: resolveSeq.intOptions,\n  stringify: resolveSeq.stringifyNumber\n};\nconst hexObj = {\n  identify: value => intIdentify$2(value) && value >= 0,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'HEX',\n  test: /^0x([0-9a-fA-F]+)$/,\n  resolve: (str, hex) => intResolve$1(str, hex, 16),\n  options: resolveSeq.intOptions,\n  stringify: node => intStringify$1(node, 16, '0x')\n};\nconst nanObj = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^(?:[-+]?\\.inf|(\\.nan))$/i,\n  resolve: (str, nan) => nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,\n  stringify: resolveSeq.stringifyNumber\n};\nconst expObj = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'EXP',\n  test: /^[-+]?(?:\\.[0-9]+|[0-9]+(?:\\.[0-9]*)?)[eE][-+]?[0-9]+$/,\n  resolve: str => parseFloat(str),\n  stringify: ({\n    value\n  }) => Number(value).toExponential()\n};\nconst floatObj = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^[-+]?(?:\\.([0-9]+)|[0-9]+\\.([0-9]*))$/,\n\n  resolve(str, frac1, frac2) {\n    const frac = frac1 || frac2;\n    const node = new resolveSeq.Scalar(parseFloat(str));\n    if (frac && frac[frac.length - 1] === '0') node.minFractionDigits = frac.length;\n    return node;\n  },\n\n  stringify: resolveSeq.stringifyNumber\n};\nconst core = failsafe.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);\n\n/* global BigInt */\n\nconst intIdentify$1 = value => typeof value === 'bigint' || Number.isInteger(value);\n\nconst stringifyJSON = ({\n  value\n}) => JSON.stringify(value);\n\nconst json = [map, seq, {\n  identify: value => typeof value === 'string',\n  default: true,\n  tag: 'tag:yaml.org,2002:str',\n  resolve: resolveSeq.resolveString,\n  stringify: stringifyJSON\n}, {\n  identify: value => value == null,\n  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,\n  default: true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^null$/,\n  resolve: () => null,\n  stringify: stringifyJSON\n}, {\n  identify: value => typeof value === 'boolean',\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^true|false$/,\n  resolve: str => str === 'true',\n  stringify: stringifyJSON\n}, {\n  identify: intIdentify$1,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^-?(?:0|[1-9][0-9]*)$/,\n  resolve: str => resolveSeq.intOptions.asBigInt ? BigInt(str) : parseInt(str, 10),\n  stringify: ({\n    value\n  }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)\n}, {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^-?(?:0|[1-9][0-9]*)(?:\\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,\n  resolve: str => parseFloat(str),\n  stringify: stringifyJSON\n}];\n\njson.scalarFallback = str => {\n  throw new SyntaxError(`Unresolved plain scalar ${JSON.stringify(str)}`);\n};\n\n/* global BigInt */\n\nconst boolStringify = ({\n  value\n}) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr;\n\nconst intIdentify = value => typeof value === 'bigint' || Number.isInteger(value);\n\nfunction intResolve(sign, src, radix) {\n  let str = src.replace(/_/g, '');\n\n  if (resolveSeq.intOptions.asBigInt) {\n    switch (radix) {\n      case 2:\n        str = `0b${str}`;\n        break;\n\n      case 8:\n        str = `0o${str}`;\n        break;\n\n      case 16:\n        str = `0x${str}`;\n        break;\n    }\n\n    const n = BigInt(str);\n    return sign === '-' ? BigInt(-1) * n : n;\n  }\n\n  const n = parseInt(str, radix);\n  return sign === '-' ? -1 * n : n;\n}\n\nfunction intStringify(node, radix, prefix) {\n  const {\n    value\n  } = node;\n\n  if (intIdentify(value)) {\n    const str = value.toString(radix);\n    return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;\n  }\n\n  return resolveSeq.stringifyNumber(node);\n}\n\nconst yaml11 = failsafe.concat([{\n  identify: value => value == null,\n  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,\n  default: true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^(?:~|[Nn]ull|NULL)?$/,\n  resolve: () => null,\n  options: resolveSeq.nullOptions,\n  stringify: () => resolveSeq.nullOptions.nullStr\n}, {\n  identify: value => typeof value === 'boolean',\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,\n  resolve: () => true,\n  options: resolveSeq.boolOptions,\n  stringify: boolStringify\n}, {\n  identify: value => typeof value === 'boolean',\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,\n  resolve: () => false,\n  options: resolveSeq.boolOptions,\n  stringify: boolStringify\n}, {\n  identify: intIdentify,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'BIN',\n  test: /^([-+]?)0b([0-1_]+)$/,\n  resolve: (str, sign, bin) => intResolve(sign, bin, 2),\n  stringify: node => intStringify(node, 2, '0b')\n}, {\n  identify: intIdentify,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'OCT',\n  test: /^([-+]?)0([0-7_]+)$/,\n  resolve: (str, sign, oct) => intResolve(sign, oct, 8),\n  stringify: node => intStringify(node, 8, '0')\n}, {\n  identify: intIdentify,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^([-+]?)([0-9][0-9_]*)$/,\n  resolve: (str, sign, abs) => intResolve(sign, abs, 10),\n  stringify: resolveSeq.stringifyNumber\n}, {\n  identify: intIdentify,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'HEX',\n  test: /^([-+]?)0x([0-9a-fA-F_]+)$/,\n  resolve: (str, sign, hex) => intResolve(sign, hex, 16),\n  stringify: node => intStringify(node, 16, '0x')\n}, {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^(?:[-+]?\\.inf|(\\.nan))$/i,\n  resolve: (str, nan) => nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,\n  stringify: resolveSeq.stringifyNumber\n}, {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'EXP',\n  test: /^[-+]?([0-9][0-9_]*)?(\\.[0-9_]*)?[eE][-+]?[0-9]+$/,\n  resolve: str => parseFloat(str.replace(/_/g, '')),\n  stringify: ({\n    value\n  }) => Number(value).toExponential()\n}, {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^[-+]?(?:[0-9][0-9_]*)?\\.([0-9_]*)$/,\n\n  resolve(str, frac) {\n    const node = new resolveSeq.Scalar(parseFloat(str.replace(/_/g, '')));\n\n    if (frac) {\n      const f = frac.replace(/_/g, '');\n      if (f[f.length - 1] === '0') node.minFractionDigits = f.length;\n    }\n\n    return node;\n  },\n\n  stringify: resolveSeq.stringifyNumber\n}], warnings.binary, warnings.omap, warnings.pairs, warnings.set, warnings.intTime, warnings.floatTime, warnings.timestamp);\n\nconst schemas = {\n  core,\n  failsafe,\n  json,\n  yaml11\n};\nconst tags = {\n  binary: warnings.binary,\n  bool: boolObj,\n  float: floatObj,\n  floatExp: expObj,\n  floatNaN: nanObj,\n  floatTime: warnings.floatTime,\n  int: intObj,\n  intHex: hexObj,\n  intOct: octObj,\n  intTime: warnings.intTime,\n  map,\n  null: nullObj,\n  omap: warnings.omap,\n  pairs: warnings.pairs,\n  seq,\n  set: warnings.set,\n  timestamp: warnings.timestamp\n};\n\nfunction findTagObject(value, tagName, tags) {\n  if (tagName) {\n    const match = tags.filter(t => t.tag === tagName);\n    const tagObj = match.find(t => !t.format) || match[0];\n    if (!tagObj) throw new Error(`Tag ${tagName} not found`);\n    return tagObj;\n  } // TODO: deprecate/remove class check\n\n\n  return tags.find(t => (t.identify && t.identify(value) || t.class && value instanceof t.class) && !t.format);\n}\n\nfunction createNode(value, tagName, ctx) {\n  if (value instanceof resolveSeq.Node) return value;\n  const {\n    defaultPrefix,\n    onTagObj,\n    prevObjects,\n    schema,\n    wrapScalars\n  } = ctx;\n  if (tagName && tagName.startsWith('!!')) tagName = defaultPrefix + tagName.slice(2);\n  let tagObj = findTagObject(value, tagName, schema.tags);\n\n  if (!tagObj) {\n    if (typeof value.toJSON === 'function') value = value.toJSON();\n    if (!value || typeof value !== 'object') return wrapScalars ? new resolveSeq.Scalar(value) : value;\n    tagObj = value instanceof Map ? map : value[Symbol.iterator] ? seq : map;\n  }\n\n  if (onTagObj) {\n    onTagObj(tagObj);\n    delete ctx.onTagObj;\n  } // Detect duplicate references to the same object & use Alias nodes for all\n  // after first. The `obj` wrapper allows for circular references to resolve.\n\n\n  const obj = {\n    value: undefined,\n    node: undefined\n  };\n\n  if (value && typeof value === 'object' && prevObjects) {\n    const prev = prevObjects.get(value);\n\n    if (prev) {\n      const alias = new resolveSeq.Alias(prev); // leaves source dirty; must be cleaned by caller\n\n      ctx.aliasNodes.push(alias); // defined along with prevObjects\n\n      return alias;\n    }\n\n    obj.value = value;\n    prevObjects.set(value, obj);\n  }\n\n  obj.node = tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : wrapScalars ? new resolveSeq.Scalar(value) : value;\n  if (tagName && obj.node instanceof resolveSeq.Node) obj.node.tag = tagName;\n  return obj.node;\n}\n\nfunction getSchemaTags(schemas, knownTags, customTags, schemaId) {\n  let tags = schemas[schemaId.replace(/\\W/g, '')]; // 'yaml-1.1' -> 'yaml11'\n\n  if (!tags) {\n    const keys = Object.keys(schemas).map(key => JSON.stringify(key)).join(', ');\n    throw new Error(`Unknown schema \"${schemaId}\"; use one of ${keys}`);\n  }\n\n  if (Array.isArray(customTags)) {\n    for (const tag of customTags) tags = tags.concat(tag);\n  } else if (typeof customTags === 'function') {\n    tags = customTags(tags.slice());\n  }\n\n  for (let i = 0; i < tags.length; ++i) {\n    const tag = tags[i];\n\n    if (typeof tag === 'string') {\n      const tagObj = knownTags[tag];\n\n      if (!tagObj) {\n        const keys = Object.keys(knownTags).map(key => JSON.stringify(key)).join(', ');\n        throw new Error(`Unknown custom tag \"${tag}\"; use one of ${keys}`);\n      }\n\n      tags[i] = tagObj;\n    }\n  }\n\n  return tags;\n}\n\nconst sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;\n\nclass Schema {\n  // TODO: remove in v2\n  // TODO: remove in v2\n  constructor({\n    customTags,\n    merge,\n    schema,\n    sortMapEntries,\n    tags: deprecatedCustomTags\n  }) {\n    this.merge = !!merge;\n    this.name = schema;\n    this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;\n    if (!customTags && deprecatedCustomTags) warnings.warnOptionDeprecation('tags', 'customTags');\n    this.tags = getSchemaTags(schemas, tags, customTags || deprecatedCustomTags, schema);\n  }\n\n  createNode(value, wrapScalars, tagName, ctx) {\n    const baseCtx = {\n      defaultPrefix: Schema.defaultPrefix,\n      schema: this,\n      wrapScalars\n    };\n    const createCtx = ctx ? Object.assign(ctx, baseCtx) : baseCtx;\n    return createNode(value, tagName, createCtx);\n  }\n\n  createPair(key, value, ctx) {\n    if (!ctx) ctx = {\n      wrapScalars: true\n    };\n    const k = this.createNode(key, ctx.wrapScalars, null, ctx);\n    const v = this.createNode(value, ctx.wrapScalars, null, ctx);\n    return new resolveSeq.Pair(k, v);\n  }\n\n}\n\nPlainValue._defineProperty(Schema, \"defaultPrefix\", PlainValue.defaultTagPrefix);\n\nPlainValue._defineProperty(Schema, \"defaultTags\", PlainValue.defaultTags);\n\nexports.Schema = Schema;\n", "'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar resolveSeq = require('./resolveSeq-d03cb037.js');\nvar Schema = require('./Schema-88e323a7.js');\n\nconst defaultOptions = {\n  anchorPrefix: 'a',\n  customTags: null,\n  indent: 2,\n  indentSeq: true,\n  keepCstNodes: false,\n  keepNodeTypes: true,\n  keepBlobsInJSON: true,\n  mapAsMap: false,\n  maxAliasCount: 100,\n  prettyErrors: false,\n  // TODO Set true in v2\n  simpleKeys: false,\n  version: '1.2'\n};\nconst scalarOptions = {\n  get binary() {\n    return resolveSeq.binaryOptions;\n  },\n\n  set binary(opt) {\n    Object.assign(resolveSeq.binaryOptions, opt);\n  },\n\n  get bool() {\n    return resolveSeq.boolOptions;\n  },\n\n  set bool(opt) {\n    Object.assign(resolveSeq.boolOptions, opt);\n  },\n\n  get int() {\n    return resolveSeq.intOptions;\n  },\n\n  set int(opt) {\n    Object.assign(resolveSeq.intOptions, opt);\n  },\n\n  get null() {\n    return resolveSeq.nullOptions;\n  },\n\n  set null(opt) {\n    Object.assign(resolveSeq.nullOptions, opt);\n  },\n\n  get str() {\n    return resolveSeq.strOptions;\n  },\n\n  set str(opt) {\n    Object.assign(resolveSeq.strOptions, opt);\n  }\n\n};\nconst documentOptions = {\n  '1.0': {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: PlainValue.defaultTagPrefix\n    }, {\n      handle: '!!',\n      prefix: 'tag:private.yaml.org,2002:'\n    }]\n  },\n  1.1: {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: PlainValue.defaultTagPrefix\n    }]\n  },\n  1.2: {\n    schema: 'core',\n    merge: false,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: PlainValue.defaultTagPrefix\n    }]\n  }\n};\n\nfunction stringifyTag(doc, tag) {\n  if ((doc.version || doc.options.version) === '1.0') {\n    const priv = tag.match(/^tag:private\\.yaml\\.org,2002:([^:/]+)$/);\n    if (priv) return '!' + priv[1];\n    const vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\\.yaml\\.org,2002:(.*)/);\n    return vocab ? `!${vocab[1]}/${vocab[2]}` : `!${tag.replace(/^tag:/, '')}`;\n  }\n\n  let p = doc.tagPrefixes.find(p => tag.indexOf(p.prefix) === 0);\n\n  if (!p) {\n    const dtp = doc.getDefaults().tagPrefixes;\n    p = dtp && dtp.find(p => tag.indexOf(p.prefix) === 0);\n  }\n\n  if (!p) return tag[0] === '!' ? tag : `!<${tag}>`;\n  const suffix = tag.substr(p.prefix.length).replace(/[!,[\\]{}]/g, ch => ({\n    '!': '%21',\n    ',': '%2C',\n    '[': '%5B',\n    ']': '%5D',\n    '{': '%7B',\n    '}': '%7D'\n  })[ch]);\n  return p.handle + suffix;\n}\n\nfunction getTagObject(tags, item) {\n  if (item instanceof resolveSeq.Alias) return resolveSeq.Alias;\n\n  if (item.tag) {\n    const match = tags.filter(t => t.tag === item.tag);\n    if (match.length > 0) return match.find(t => t.format === item.format) || match[0];\n  }\n\n  let tagObj, obj;\n\n  if (item instanceof resolveSeq.Scalar) {\n    obj = item.value; // TODO: deprecate/remove class check\n\n    const match = tags.filter(t => t.identify && t.identify(obj) || t.class && obj instanceof t.class);\n    tagObj = match.find(t => t.format === item.format) || match.find(t => !t.format);\n  } else {\n    obj = item;\n    tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);\n  }\n\n  if (!tagObj) {\n    const name = obj && obj.constructor ? obj.constructor.name : typeof obj;\n    throw new Error(`Tag not resolved for ${name} value`);\n  }\n\n  return tagObj;\n} // needs to be called before value stringifier to allow for circular anchor refs\n\n\nfunction stringifyProps(node, tagObj, {\n  anchors,\n  doc\n}) {\n  const props = [];\n  const anchor = doc.anchors.getName(node);\n\n  if (anchor) {\n    anchors[anchor] = node;\n    props.push(`&${anchor}`);\n  }\n\n  if (node.tag) {\n    props.push(stringifyTag(doc, node.tag));\n  } else if (!tagObj.default) {\n    props.push(stringifyTag(doc, tagObj.tag));\n  }\n\n  return props.join(' ');\n}\n\nfunction stringify(item, ctx, onComment, onChompKeep) {\n  const {\n    anchors,\n    schema\n  } = ctx.doc;\n  let tagObj;\n\n  if (!(item instanceof resolveSeq.Node)) {\n    const createCtx = {\n      aliasNodes: [],\n      onTagObj: o => tagObj = o,\n      prevObjects: new Map()\n    };\n    item = schema.createNode(item, true, null, createCtx);\n\n    for (const alias of createCtx.aliasNodes) {\n      alias.source = alias.source.node;\n      let name = anchors.getName(alias.source);\n\n      if (!name) {\n        name = anchors.newName();\n        anchors.map[name] = alias.source;\n      }\n    }\n  }\n\n  if (item instanceof resolveSeq.Pair) return item.toString(ctx, onComment, onChompKeep);\n  if (!tagObj) tagObj = getTagObject(schema.tags, item);\n  const props = stringifyProps(item, tagObj, ctx);\n  if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;\n  const str = typeof tagObj.stringify === 'function' ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof resolveSeq.Scalar ? resolveSeq.stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);\n  if (!props) return str;\n  return item instanceof resolveSeq.Scalar || str[0] === '{' || str[0] === '[' ? `${props} ${str}` : `${props}\\n${ctx.indent}${str}`;\n}\n\nclass Anchors {\n  static validAnchorNode(node) {\n    return node instanceof resolveSeq.Scalar || node instanceof resolveSeq.YAMLSeq || node instanceof resolveSeq.YAMLMap;\n  }\n\n  constructor(prefix) {\n    PlainValue._defineProperty(this, \"map\", Object.create(null));\n\n    this.prefix = prefix;\n  }\n\n  createAlias(node, name) {\n    this.setAnchor(node, name);\n    return new resolveSeq.Alias(node);\n  }\n\n  createMergePair(...sources) {\n    const merge = new resolveSeq.Merge();\n    merge.value.items = sources.map(s => {\n      if (s instanceof resolveSeq.Alias) {\n        if (s.source instanceof resolveSeq.YAMLMap) return s;\n      } else if (s instanceof resolveSeq.YAMLMap) {\n        return this.createAlias(s);\n      }\n\n      throw new Error('Merge sources must be Map nodes or their Aliases');\n    });\n    return merge;\n  }\n\n  getName(node) {\n    const {\n      map\n    } = this;\n    return Object.keys(map).find(a => map[a] === node);\n  }\n\n  getNames() {\n    return Object.keys(this.map);\n  }\n\n  getNode(name) {\n    return this.map[name];\n  }\n\n  newName(prefix) {\n    if (!prefix) prefix = this.prefix;\n    const names = Object.keys(this.map);\n\n    for (let i = 1; true; ++i) {\n      const name = `${prefix}${i}`;\n      if (!names.includes(name)) return name;\n    }\n  } // During parsing, map & aliases contain CST nodes\n\n\n  resolveNodes() {\n    const {\n      map,\n      _cstAliases\n    } = this;\n    Object.keys(map).forEach(a => {\n      map[a] = map[a].resolved;\n    });\n\n    _cstAliases.forEach(a => {\n      a.source = a.source.resolved;\n    });\n\n    delete this._cstAliases;\n  }\n\n  setAnchor(node, name) {\n    if (node != null && !Anchors.validAnchorNode(node)) {\n      throw new Error('Anchors may only be set for Scalar, Seq and Map nodes');\n    }\n\n    if (name && /[\\x00-\\x19\\s,[\\]{}]/.test(name)) {\n      throw new Error('Anchor names must not contain whitespace or control characters');\n    }\n\n    const {\n      map\n    } = this;\n    const prev = node && Object.keys(map).find(a => map[a] === node);\n\n    if (prev) {\n      if (!name) {\n        return prev;\n      } else if (prev !== name) {\n        delete map[prev];\n        map[name] = node;\n      }\n    } else {\n      if (!name) {\n        if (!node) return null;\n        name = this.newName();\n      }\n\n      map[name] = node;\n    }\n\n    return name;\n  }\n\n}\n\nconst visit = (node, tags) => {\n  if (node && typeof node === 'object') {\n    const {\n      tag\n    } = node;\n\n    if (node instanceof resolveSeq.Collection) {\n      if (tag) tags[tag] = true;\n      node.items.forEach(n => visit(n, tags));\n    } else if (node instanceof resolveSeq.Pair) {\n      visit(node.key, tags);\n      visit(node.value, tags);\n    } else if (node instanceof resolveSeq.Scalar) {\n      if (tag) tags[tag] = true;\n    }\n  }\n\n  return tags;\n};\n\nconst listTagNames = node => Object.keys(visit(node, {}));\n\nfunction parseContents(doc, contents) {\n  const comments = {\n    before: [],\n    after: []\n  };\n  let body = undefined;\n  let spaceBefore = false;\n\n  for (const node of contents) {\n    if (node.valueRange) {\n      if (body !== undefined) {\n        const msg = 'Document contains trailing content not separated by a ... or --- line';\n        doc.errors.push(new PlainValue.YAMLSyntaxError(node, msg));\n        break;\n      }\n\n      const res = resolveSeq.resolveNode(doc, node);\n\n      if (spaceBefore) {\n        res.spaceBefore = true;\n        spaceBefore = false;\n      }\n\n      body = res;\n    } else if (node.comment !== null) {\n      const cc = body === undefined ? comments.before : comments.after;\n      cc.push(node.comment);\n    } else if (node.type === PlainValue.Type.BLANK_LINE) {\n      spaceBefore = true;\n\n      if (body === undefined && comments.before.length > 0 && !doc.commentBefore) {\n        // space-separated comments at start are parsed as document comments\n        doc.commentBefore = comments.before.join('\\n');\n        comments.before = [];\n      }\n    }\n  }\n\n  doc.contents = body || null;\n\n  if (!body) {\n    doc.comment = comments.before.concat(comments.after).join('\\n') || null;\n  } else {\n    const cb = comments.before.join('\\n');\n\n    if (cb) {\n      const cbNode = body instanceof resolveSeq.Collection && body.items[0] ? body.items[0] : body;\n      cbNode.commentBefore = cbNode.commentBefore ? `${cb}\\n${cbNode.commentBefore}` : cb;\n    }\n\n    doc.comment = comments.after.join('\\n') || null;\n  }\n}\n\nfunction resolveTagDirective({\n  tagPrefixes\n}, directive) {\n  const [handle, prefix] = directive.parameters;\n\n  if (!handle || !prefix) {\n    const msg = 'Insufficient parameters given for %TAG directive';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  if (tagPrefixes.some(p => p.handle === handle)) {\n    const msg = 'The %TAG directive must only be given at most once per handle in the same document.';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  return {\n    handle,\n    prefix\n  };\n}\n\nfunction resolveYamlDirective(doc, directive) {\n  let [version] = directive.parameters;\n  if (directive.name === 'YAML:1.0') version = '1.0';\n\n  if (!version) {\n    const msg = 'Insufficient parameters given for %YAML directive';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  if (!documentOptions[version]) {\n    const v0 = doc.version || doc.options.version;\n    const msg = `Document will be parsed as YAML ${v0} rather than YAML ${version}`;\n    doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));\n  }\n\n  return version;\n}\n\nfunction parseDirectives(doc, directives, prevDoc) {\n  const directiveComments = [];\n  let hasDirectives = false;\n\n  for (const directive of directives) {\n    const {\n      comment,\n      name\n    } = directive;\n\n    switch (name) {\n      case 'TAG':\n        try {\n          doc.tagPrefixes.push(resolveTagDirective(doc, directive));\n        } catch (error) {\n          doc.errors.push(error);\n        }\n\n        hasDirectives = true;\n        break;\n\n      case 'YAML':\n      case 'YAML:1.0':\n        if (doc.version) {\n          const msg = 'The %YAML directive must only be given at most once per document.';\n          doc.errors.push(new PlainValue.YAMLSemanticError(directive, msg));\n        }\n\n        try {\n          doc.version = resolveYamlDirective(doc, directive);\n        } catch (error) {\n          doc.errors.push(error);\n        }\n\n        hasDirectives = true;\n        break;\n\n      default:\n        if (name) {\n          const msg = `YAML only supports %TAG and %YAML directives, and not %${name}`;\n          doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));\n        }\n\n    }\n\n    if (comment) directiveComments.push(comment);\n  }\n\n  if (prevDoc && !hasDirectives && '1.1' === (doc.version || prevDoc.version || doc.options.version)) {\n    const copyTagPrefix = ({\n      handle,\n      prefix\n    }) => ({\n      handle,\n      prefix\n    });\n\n    doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);\n    doc.version = prevDoc.version;\n  }\n\n  doc.commentBefore = directiveComments.join('\\n') || null;\n}\n\nfunction assertCollection(contents) {\n  if (contents instanceof resolveSeq.Collection) return true;\n  throw new Error('Expected a YAML collection as document contents');\n}\n\nclass Document {\n  constructor(options) {\n    this.anchors = new Anchors(options.anchorPrefix);\n    this.commentBefore = null;\n    this.comment = null;\n    this.contents = null;\n    this.directivesEndMarker = null;\n    this.errors = [];\n    this.options = options;\n    this.schema = null;\n    this.tagPrefixes = [];\n    this.version = null;\n    this.warnings = [];\n  }\n\n  add(value) {\n    assertCollection(this.contents);\n    return this.contents.add(value);\n  }\n\n  addIn(path, value) {\n    assertCollection(this.contents);\n    this.contents.addIn(path, value);\n  }\n\n  delete(key) {\n    assertCollection(this.contents);\n    return this.contents.delete(key);\n  }\n\n  deleteIn(path) {\n    if (resolveSeq.isEmptyPath(path)) {\n      if (this.contents == null) return false;\n      this.contents = null;\n      return true;\n    }\n\n    assertCollection(this.contents);\n    return this.contents.deleteIn(path);\n  }\n\n  getDefaults() {\n    return Document.defaults[this.version] || Document.defaults[this.options.version] || {};\n  }\n\n  get(key, keepScalar) {\n    return this.contents instanceof resolveSeq.Collection ? this.contents.get(key, keepScalar) : undefined;\n  }\n\n  getIn(path, keepScalar) {\n    if (resolveSeq.isEmptyPath(path)) return !keepScalar && this.contents instanceof resolveSeq.Scalar ? this.contents.value : this.contents;\n    return this.contents instanceof resolveSeq.Collection ? this.contents.getIn(path, keepScalar) : undefined;\n  }\n\n  has(key) {\n    return this.contents instanceof resolveSeq.Collection ? this.contents.has(key) : false;\n  }\n\n  hasIn(path) {\n    if (resolveSeq.isEmptyPath(path)) return this.contents !== undefined;\n    return this.contents instanceof resolveSeq.Collection ? this.contents.hasIn(path) : false;\n  }\n\n  set(key, value) {\n    assertCollection(this.contents);\n    this.contents.set(key, value);\n  }\n\n  setIn(path, value) {\n    if (resolveSeq.isEmptyPath(path)) this.contents = value;else {\n      assertCollection(this.contents);\n      this.contents.setIn(path, value);\n    }\n  }\n\n  setSchema(id, customTags) {\n    if (!id && !customTags && this.schema) return;\n    if (typeof id === 'number') id = id.toFixed(1);\n\n    if (id === '1.0' || id === '1.1' || id === '1.2') {\n      if (this.version) this.version = id;else this.options.version = id;\n      delete this.options.schema;\n    } else if (id && typeof id === 'string') {\n      this.options.schema = id;\n    }\n\n    if (Array.isArray(customTags)) this.options.customTags = customTags;\n    const opt = Object.assign({}, this.getDefaults(), this.options);\n    this.schema = new Schema.Schema(opt);\n  }\n\n  parse(node, prevDoc) {\n    if (this.options.keepCstNodes) this.cstNode = node;\n    if (this.options.keepNodeTypes) this.type = 'DOCUMENT';\n    const {\n      directives = [],\n      contents = [],\n      directivesEndMarker,\n      error,\n      valueRange\n    } = node;\n\n    if (error) {\n      if (!error.source) error.source = this;\n      this.errors.push(error);\n    }\n\n    parseDirectives(this, directives, prevDoc);\n    if (directivesEndMarker) this.directivesEndMarker = true;\n    this.range = valueRange ? [valueRange.start, valueRange.end] : null;\n    this.setSchema();\n    this.anchors._cstAliases = [];\n    parseContents(this, contents);\n    this.anchors.resolveNodes();\n\n    if (this.options.prettyErrors) {\n      for (const error of this.errors) if (error instanceof PlainValue.YAMLError) error.makePretty();\n\n      for (const warn of this.warnings) if (warn instanceof PlainValue.YAMLError) warn.makePretty();\n    }\n\n    return this;\n  }\n\n  listNonDefaultTags() {\n    return listTagNames(this.contents).filter(t => t.indexOf(Schema.Schema.defaultPrefix) !== 0);\n  }\n\n  setTagPrefix(handle, prefix) {\n    if (handle[0] !== '!' || handle[handle.length - 1] !== '!') throw new Error('Handle must start and end with !');\n\n    if (prefix) {\n      const prev = this.tagPrefixes.find(p => p.handle === handle);\n      if (prev) prev.prefix = prefix;else this.tagPrefixes.push({\n        handle,\n        prefix\n      });\n    } else {\n      this.tagPrefixes = this.tagPrefixes.filter(p => p.handle !== handle);\n    }\n  }\n\n  toJSON(arg, onAnchor) {\n    const {\n      keepBlobsInJSON,\n      mapAsMap,\n      maxAliasCount\n    } = this.options;\n    const keep = keepBlobsInJSON && (typeof arg !== 'string' || !(this.contents instanceof resolveSeq.Scalar));\n    const ctx = {\n      doc: this,\n      indentStep: '  ',\n      keep,\n      mapAsMap: keep && !!mapAsMap,\n      maxAliasCount,\n      stringify // Requiring directly in Pair would create circular dependencies\n\n    };\n    const anchorNames = Object.keys(this.anchors.map);\n    if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map(name => [this.anchors.map[name], {\n      alias: [],\n      aliasCount: 0,\n      count: 1\n    }]));\n    const res = resolveSeq.toJSON(this.contents, arg, ctx);\n    if (typeof onAnchor === 'function' && ctx.anchors) for (const {\n      count,\n      res\n    } of ctx.anchors.values()) onAnchor(res, count);\n    return res;\n  }\n\n  toString() {\n    if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');\n    const indentSize = this.options.indent;\n\n    if (!Number.isInteger(indentSize) || indentSize <= 0) {\n      const s = JSON.stringify(indentSize);\n      throw new Error(`\"indent\" option must be a positive integer, not ${s}`);\n    }\n\n    this.setSchema();\n    const lines = [];\n    let hasDirectives = false;\n\n    if (this.version) {\n      let vd = '%YAML 1.2';\n\n      if (this.schema.name === 'yaml-1.1') {\n        if (this.version === '1.0') vd = '%YAML:1.0';else if (this.version === '1.1') vd = '%YAML 1.1';\n      }\n\n      lines.push(vd);\n      hasDirectives = true;\n    }\n\n    const tagNames = this.listNonDefaultTags();\n    this.tagPrefixes.forEach(({\n      handle,\n      prefix\n    }) => {\n      if (tagNames.some(t => t.indexOf(prefix) === 0)) {\n        lines.push(`%TAG ${handle} ${prefix}`);\n        hasDirectives = true;\n      }\n    });\n    if (hasDirectives || this.directivesEndMarker) lines.push('---');\n\n    if (this.commentBefore) {\n      if (hasDirectives || !this.directivesEndMarker) lines.unshift('');\n      lines.unshift(this.commentBefore.replace(/^/gm, '#'));\n    }\n\n    const ctx = {\n      anchors: Object.create(null),\n      doc: this,\n      indent: '',\n      indentStep: ' '.repeat(indentSize),\n      stringify // Requiring directly in nodes would create circular dependencies\n\n    };\n    let chompKeep = false;\n    let contentComment = null;\n\n    if (this.contents) {\n      if (this.contents instanceof resolveSeq.Node) {\n        if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push('');\n        if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, '#')); // top-level block scalars need to be indented if followed by a comment\n\n        ctx.forceBlockIndent = !!this.comment;\n        contentComment = this.contents.comment;\n      }\n\n      const onChompKeep = contentComment ? null : () => chompKeep = true;\n      const body = stringify(this.contents, ctx, () => contentComment = null, onChompKeep);\n      lines.push(resolveSeq.addComment(body, '', contentComment));\n    } else if (this.contents !== undefined) {\n      lines.push(stringify(this.contents, ctx));\n    }\n\n    if (this.comment) {\n      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');\n      lines.push(this.comment.replace(/^/gm, '#'));\n    }\n\n    return lines.join('\\n') + '\\n';\n  }\n\n}\n\nPlainValue._defineProperty(Document, \"defaults\", documentOptions);\n\nexports.Document = Document;\nexports.defaultOptions = defaultOptions;\nexports.scalarOptions = scalarOptions;\n", "'use strict';\n\nvar parseCst = require('./parse-cst.js');\nvar Document$1 = require('./Document-9b4560a1.js');\nvar Schema = require('./Schema-88e323a7.js');\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar warnings = require('./warnings-1000a372.js');\nrequire('./resolveSeq-d03cb037.js');\n\nfunction createNode(value, wrapScalars = true, tag) {\n  if (tag === undefined && typeof wrapScalars === 'string') {\n    tag = wrapScalars;\n    wrapScalars = true;\n  }\n\n  const options = Object.assign({}, Document$1.Document.defaults[Document$1.defaultOptions.version], Document$1.defaultOptions);\n  const schema = new Schema.Schema(options);\n  return schema.createNode(value, wrapScalars, tag);\n}\n\nclass Document extends Document$1.Document {\n  constructor(options) {\n    super(Object.assign({}, Document$1.defaultOptions, options));\n  }\n\n}\n\nfunction parseAllDocuments(src, options) {\n  const stream = [];\n  let prev;\n\n  for (const cstDoc of parseCst.parse(src)) {\n    const doc = new Document(options);\n    doc.parse(cstDoc, prev);\n    stream.push(doc);\n    prev = doc;\n  }\n\n  return stream;\n}\n\nfunction parseDocument(src, options) {\n  const cst = parseCst.parse(src);\n  const doc = new Document(options).parse(cst[0]);\n\n  if (cst.length > 1) {\n    const errMsg = 'Source contains multiple documents; please use YAML.parseAllDocuments()';\n    doc.errors.unshift(new PlainValue.YAMLSemanticError(cst[1], errMsg));\n  }\n\n  return doc;\n}\n\nfunction parse(src, options) {\n  const doc = parseDocument(src, options);\n  doc.warnings.forEach(warning => warnings.warn(warning));\n  if (doc.errors.length > 0) throw doc.errors[0];\n  return doc.toJSON();\n}\n\nfunction stringify(value, options) {\n  const doc = new Document(options);\n  doc.contents = value;\n  return String(doc);\n}\n\nconst YAML = {\n  createNode,\n  defaultOptions: Document$1.defaultOptions,\n  Document,\n  parse,\n  parseAllDocuments,\n  parseCST: parseCst.parse,\n  parseDocument,\n  scalarOptions: Document$1.scalarOptions,\n  stringify\n};\n\nexports.YAML = YAML;\n", "module.exports = require('./dist').YAML\n", "const yaml = require(\"yaml\");\n\n// see: https://eemeli.org/yaml/v1/#errors\nconst errors = new Set([\n  \"YAMLReferenceError\",\n  \"YAMLSemanticError\",\n  \"YAMLSyntaxError\",\n  \"YAMLWarning\",\n]);\n\nfunction parse(str) {\n  if (typeof str !== \"string\") {\n    return { ok: false, result: undefined };\n  }\n\n  const YAML_SILENCE_WARNINGS_CACHED = global.YAML_SILENCE_WARNINGS;\n  try {\n    // see: https://eemeli.org/yaml/v1/#silencing-warnings\n    global.YAML_SILENCE_WARNINGS = true;\n    return { ok: true, result: yaml.parse(str) };\n  } catch (err) {\n    // Ignore parser errors.\n    if (err && errors.has(err.name)) {\n      return { ok: false, result: undefined };\n    }\n    throw err;\n  } finally {\n    global.YAML_SILENCE_WARNINGS = YAML_SILENCE_WARNINGS_CACHED;\n  }\n}\n\nmodule.exports = {\n  // is_valid is expected to return nothing if input is invalid otherwise\n  // true/false for it being valid YAML.\n  \"yaml.is_valid\": (str) => typeof str === \"string\" ? parse(str).ok : undefined,\n  \"yaml.marshal\": (data) => yaml.stringify(data),\n  \"yaml.unmarshal\": (str) => parse(str).result,\n};\n", "const json = require(\"./json\");\nconst strings = require(\"./strings\");\nconst regex = require(\"./regex\");\nconst yaml = require(\"./yaml\");\n\nmodule.exports = {\n  ...json,\n  ...strings,\n  ...regex,\n  ...yaml,\n};\n", "// Copyright 2018 The OPA Authors.  All rights reserved.\n// Use of this source code is governed by an Apache2\n// license that can be found in the LICENSE file.\nconst builtIns = require(\"./builtins/index\");\n\n/**\n * @param {WebAssembly.Memory} mem\n */\nfunction stringDecoder(mem) {\n  return function (addr) {\n    const i8 = new Int8Array(mem.buffer);\n    let s = \"\";\n    while (i8[addr] !== 0) {\n      s += String.fromCharCode(i8[addr++]);\n    }\n    return s;\n  };\n}\n\n/**\n * Stringifies and loads an object into OPA's Memory\n * @param {WebAssembly.Instance} wasmInstance\n * @param {WebAssembly.Memory} memory\n * @param {any | ArrayBuffer} value data as `object`, literal primitive or ArrayBuffer (last is assumed to be a well-formed stringified JSON)\n * @returns {number}\n */\nfunction _loadJSON(wasmInstance, memory, value) {\n  if (value === undefined) {\n    return 0;\n  }\n\n  let valueBuf;\n  if (value instanceof ArrayBuffer) {\n    valueBuf = new Uint8Array(value);\n  } else {\n    const valueAsText = JSON.stringify(value);\n    valueBuf = new TextEncoder().encode(valueAsText);\n  }\n\n  const valueBufLen = valueBuf.byteLength;\n  const rawAddr = wasmInstance.exports.opa_malloc(valueBufLen);\n  const memoryBuffer = new Uint8Array(memory.buffer);\n  memoryBuffer.set(valueBuf, rawAddr);\n\n  const parsedAddr = wasmInstance.exports.opa_json_parse(rawAddr, valueBufLen);\n\n  if (parsedAddr === 0) {\n    throw \"failed to parse json value\";\n  }\n  return parsedAddr;\n}\n\n/**\n * Dumps and parses a JSON object from OPA's Memory\n * @param {WebAssembly.Instance} wasmInstance\n * @param {WebAssembly.Memory} memory\n * @param {number} addr\n * @returns {object}\n */\nfunction _dumpJSON(wasmInstance, memory, addr) {\n  const rawAddr = wasmInstance.exports.opa_json_dump(addr);\n  return _dumpJSONRaw(memory, rawAddr);\n}\n\n/**\n * Parses a JSON object from wasm instance's memory\n * @param {WebAssembly.Memory} memory\n * @param {number} addr\n * @returns {object}\n */\nfunction _dumpJSONRaw(memory, addr) {\n  const buf = new Uint8Array(memory.buffer);\n\n  let idx = addr;\n\n  while (buf[idx] !== 0) {\n    idx++;\n  }\n\n  const utf8View = new Uint8Array(memory.buffer, addr, idx - addr);\n  const jsonAsText = new TextDecoder().decode(utf8View);\n\n  return JSON.parse(jsonAsText);\n}\n\nconst builtinFuncs = builtIns;\n\n/**\n * _builtinCall dispatches the built-in function. The built-in function\n * arguments are loaded from Wasm and back in using JSON serialization.\n * @param {WebAssembly.Instance} wasmInstance\n * @param {WebAssembly.Memory} memory\n * @param {{ [builtinId: number]: string }} builtins\n * @param {{ [builtinName: string]: Function }} customBuiltins\n * @param {string} builtin_id\n */\nfunction _builtinCall(\n  wasmInstance,\n  memory,\n  builtins,\n  customBuiltins,\n  builtinId,\n) {\n  const builtInName = builtins[builtinId];\n  const impl = builtinFuncs[builtInName] || customBuiltins[builtInName];\n\n  if (impl === undefined) {\n    throw {\n      message: \"not implemented: built-in function \" +\n        builtinId +\n        \": \" +\n        builtins[builtinId],\n    };\n  }\n\n  const argArray = Array.prototype.slice.apply(arguments);\n  const args = [];\n\n  for (let i = 5; i < argArray.length; i++) {\n    const jsArg = _dumpJSON(wasmInstance, memory, argArray[i]);\n    args.push(jsArg);\n  }\n\n  const result = impl(...args);\n\n  return _loadJSON(wasmInstance, memory, result);\n}\n\n/**\n * _importObject builds the WebAssembly.Imports\n * @param {Object} env\n * @param {WebAssembly.Memory} memory\n * @param {{ [builtinName: string]: Function }} customBuiltins\n * @returns {WebAssembly.Imports}\n */\nfunction _importObject(env, memory, customBuiltins) {\n  const addr2string = stringDecoder(memory);\n\n  return {\n    env: {\n      memory,\n      opa_abort: function (addr) {\n        throw addr2string(addr);\n      },\n      opa_println: function (addr) {\n        console.log(addr2string(addr));\n      },\n      opa_builtin0: function (builtinId, _ctx) {\n        return _builtinCall(\n          env.instance,\n          memory,\n          env.builtins,\n          customBuiltins,\n          builtinId,\n        );\n      },\n      opa_builtin1: function (builtinId, _ctx, arg1) {\n        return _builtinCall(\n          env.instance,\n          memory,\n          env.builtins,\n          customBuiltins,\n          builtinId,\n          arg1,\n        );\n      },\n      opa_builtin2: function (builtinId, _ctx, arg1, arg2) {\n        return _builtinCall(\n          env.instance,\n          memory,\n          env.builtins,\n          customBuiltins,\n          builtinId,\n          arg1,\n          arg2,\n        );\n      },\n      opa_builtin3: function (builtinId, _ctx, arg1, arg2, arg3) {\n        return _builtinCall(\n          env.instance,\n          memory,\n          env.builtins,\n          customBuiltins,\n          builtinId,\n          arg1,\n          arg2,\n          arg3,\n        );\n      },\n      opa_builtin4: function (builtinId, _ctx, arg1, arg2, arg3, arg4) {\n        return _builtinCall(\n          env.instance,\n          memory,\n          env.builtins,\n          customBuiltins,\n          builtinId,\n          arg1,\n          arg2,\n          arg3,\n          arg4,\n        );\n      },\n    },\n  };\n}\n\n/**\n * _preparePolicy checks the ABI version and loads the built-in functions\n * @param {Object} env\n * @param {WebAssembly.WebAssemblyInstantiatedSource | WebAssembly.Instance} wasm\n * @param {WebAssembly.Memory} memory\n * @returns { policy: WebAssembly.WebAssemblyInstantiatedSource | WebAssembly.Instance, minorVersion: number }}\n */\nfunction _preparePolicy(env, wasm, memory) {\n  env.instance = wasm.instance ? wasm.instance : wasm;\n\n  // Note: On Node 10.x this value is a number on Node 12.x and up it is\n  // an object with numberic `value` property.\n  const abiVersionGlobal = env.instance.exports.opa_wasm_abi_version;\n  if (abiVersionGlobal !== undefined) {\n    const abiVersion = typeof abiVersionGlobal === \"number\"\n      ? abiVersionGlobal\n      : abiVersionGlobal.value;\n    if (abiVersion !== 1) {\n      throw `unsupported ABI version ${abiVersion}`;\n    }\n  } else {\n    console.error(\"opa_wasm_abi_version undefined\"); // logs to stderr\n  }\n\n  const abiMinorVersionGlobal = env.instance.exports.opa_wasm_abi_minor_version;\n  let abiMinorVersion;\n  if (abiMinorVersionGlobal !== undefined) {\n    abiMinorVersion = typeof abiMinorVersionGlobal === \"number\"\n      ? abiMinorVersionGlobal\n      : abiMinorVersionGlobal.value;\n  } else {\n    console.error(\"opa_wasm_abi_minor_version undefined\");\n  }\n\n  const builtins = _dumpJSON(\n    env.instance,\n    memory,\n    env.instance.exports.builtins(),\n  );\n\n  /** @type {typeof builtIns} */\n  env.builtins = {};\n\n  for (const key of Object.keys(builtins)) {\n    env.builtins[builtins[key]] = key;\n  }\n\n  return { policy: wasm, minorVersion: abiMinorVersion };\n}\n\n/**\n * _loadPolicy can take in either an ArrayBuffer or WebAssembly.Module\n * as its first argument, a WebAssembly.Memory for the second parameter,\n * and an object mapping string names to additional builtin functions for\n * the third parameter.\n * It will return a Promise, depending on the input type the promise\n * resolves to both a compiled WebAssembly.Module and its first WebAssembly.Instance\n * or to the WebAssemblyInstance.\n * @param {BufferSource | WebAssembly.Module | Response | Promise<Response>} policyWasm\n * @param {WebAssembly.Memory} memory\n * @param {{ [builtinName: string]: Function }} customBuiltins\n * @returns {Promise<{ policy: WebAssembly.WebAssemblyInstantiatedSource | WebAssembly.Instance, minorVersion: number }>}\n */\nasync function _loadPolicy(policyWasm, memory, customBuiltins) {\n  const env = {};\n\n  const isStreaming = policyWasm instanceof Response ||\n    policyWasm instanceof Promise;\n\n  const importObject = _importObject(env, memory, customBuiltins);\n\n  const wasm =\n    await (isStreaming\n      ? WebAssembly.instantiateStreaming(policyWasm, importObject)\n      : WebAssembly.instantiate(policyWasm, importObject));\n\n  return _preparePolicy(env, wasm, memory);\n}\n\n/**\n * _loadPolicySync can take in either an ArrayBuffer or WebAssembly.Module\n * as its first argument, a WebAssembly.Memory for the second parameter,\n * and an object mapping string names to additional builtin functions for\n * the third parameter.\n * It will return a compiled WebAssembly.Module and its first WebAssembly.Instance.\n * @param {BufferSource | WebAssembly.Module} policyWasm\n * @param {WebAssembly.Memory} memory\n * @param {{ [builtinName: string]: Function }} customBuiltins\n * @returns {Promise<{ policy: WebAssembly.Instance, minorVersion: number }>}\n */\nfunction _loadPolicySync(policyWasm, memory, customBuiltins) {\n  const env = {};\n\n  if (\n    policyWasm instanceof ArrayBuffer ||\n    policyWasm.buffer instanceof ArrayBuffer\n  ) {\n    policyWasm = new WebAssembly.Module(policyWasm);\n  }\n\n  const wasm = new WebAssembly.Instance(\n    policyWasm,\n    _importObject(env, memory, customBuiltins),\n  );\n\n  return _preparePolicy(env, wasm, memory);\n}\n\n/**\n * LoadedPolicy is a wrapper around a WebAssembly.Instance and WebAssembly.Memory\n * for a compiled Rego policy. There are helpers to run the wasm instance and\n * handle the output from the policy wasm.\n */\nclass LoadedPolicy {\n  /**\n   * Loads and initializes a compiled Rego policy.\n   * @param {WebAssembly.WebAssemblyInstantiatedSource} policy\n   * @param {WebAssembly.Memory} memory\n   */\n  constructor(policy, memory, minorVersion) {\n    this.minorVersion = minorVersion;\n    this.mem = memory;\n\n    // Depending on how the wasm was instantiated \"policy\" might be a\n    // WebAssembly Instance or be a wrapper around the Module and\n    // Instance. We only care about the Instance.\n    this.wasmInstance = policy.instance ? policy.instance : policy;\n\n    this.dataAddr = _loadJSON(this.wasmInstance, this.mem, {});\n    this.baseHeapPtr = this.wasmInstance.exports.opa_heap_ptr_get();\n    this.dataHeapPtr = this.baseHeapPtr;\n    this.entrypoints = _dumpJSON(\n      this.wasmInstance,\n      this.mem,\n      this.wasmInstance.exports.entrypoints(),\n    );\n  }\n\n  /**\n   * Evaluates the loaded policy with the given input and\n   * return the result set. This should be re-used for multiple evaluations\n   * of the same policy with different inputs.\n   *\n   * To call a non-default entrypoint in your WASM specify it as the second\n   * param. A list of entrypoints can be accessed with the `this.entrypoints`\n   * property.\n   * @param {any | ArrayBuffer} input input to be evaluated in form of `object`, literal primitive or ArrayBuffer (last is assumed to be a well-formed stringified JSON)\n   * @param {number | string} entrypoint ID or name of the entrypoint to call (optional)\n   */\n  evaluate(input, entrypoint = 0) {\n    // determine entrypoint ID\n    if (typeof entrypoint === \"number\") {\n      // used as-is\n    } else if (typeof entrypoint === \"string\") {\n      if (Object.prototype.hasOwnProperty.call(this.entrypoints, entrypoint)) {\n        entrypoint = this.entrypoints[entrypoint];\n      } else {\n        throw `entrypoint ${entrypoint} is not valid in this instance`;\n      }\n    } else {\n      throw `entrypoint value is an invalid type, must be either string or number`;\n    }\n\n    // ABI 1.2 fastpath\n    if (this.minorVersion >= 2) {\n      // write input into memory, adjust heap pointer\n      let inputBuf = null;\n      let inputLen = 0;\n      let inputAddr = 0;\n      if (input) {\n        if (input instanceof ArrayBuffer) {\n          inputBuf = new Uint8Array(input);\n        } else {\n          const inputAsText = JSON.stringify(input);\n          inputBuf = new TextEncoder().encode(inputAsText);\n        }\n\n        inputAddr = this.dataHeapPtr;\n        inputLen = inputBuf.byteLength;\n        const delta = inputAddr + inputLen - this.mem.buffer.byteLength;\n        if (delta > 0) {\n          const pages = roundup(delta);\n          this.mem.grow(pages);\n        }\n        const buf = new Uint8Array(this.mem.buffer);\n        buf.set(inputBuf, this.dataHeapPtr);\n      }\n\n      // opa_eval will update the Instance heap pointer to the value below\n      const heapPtr = this.dataHeapPtr + inputLen;\n\n      const ret = this.wasmInstance.exports.opa_eval(\n        0,\n        entrypoint,\n        this.dataAddr,\n        inputAddr,\n        inputLen,\n        heapPtr,\n        0,\n      );\n      return _dumpJSONRaw(this.mem, ret);\n    }\n\n    // Reset the heap pointer before each evaluation\n    this.wasmInstance.exports.opa_heap_ptr_set(this.dataHeapPtr);\n\n    // Load the input data\n    const inputAddr = _loadJSON(this.wasmInstance, this.mem, input);\n\n    // Setup the evaluation context\n    const ctxAddr = this.wasmInstance.exports.opa_eval_ctx_new();\n    this.wasmInstance.exports.opa_eval_ctx_set_input(ctxAddr, inputAddr);\n    this.wasmInstance.exports.opa_eval_ctx_set_data(ctxAddr, this.dataAddr);\n    this.wasmInstance.exports.opa_eval_ctx_set_entrypoint(ctxAddr, entrypoint);\n\n    // Actually evaluate the policy\n    this.wasmInstance.exports.eval(ctxAddr);\n\n    // Retrieve the result\n    const resultAddr = this.wasmInstance.exports.opa_eval_ctx_get_result(\n      ctxAddr,\n    );\n    return _dumpJSON(this.wasmInstance, this.mem, resultAddr);\n  }\n\n  /**\n   * evalBool will evaluate the policy and return a boolean answer\n   * depending on the return code from the policy evaluation.\n   * @deprecated Use `evaluate` instead.\n   * @param {object} input\n   */\n  evalBool(input) {\n    const rs = this.evaluate(input);\n    return rs && rs.length === 1 && rs[0] === true;\n  }\n\n  /**\n   * Loads data for use in subsequent evaluations.\n   * @param {object | ArrayBuffer} data  data in form of `object` or ArrayBuffer (last is assumed to be a well-formed stringified JSON)\n   */\n  setData(data) {\n    this.wasmInstance.exports.opa_heap_ptr_set(this.baseHeapPtr);\n    this.dataAddr = _loadJSON(this.wasmInstance, this.mem, data);\n    this.dataHeapPtr = this.wasmInstance.exports.opa_heap_ptr_get();\n  }\n}\n\nfunction roundup(bytes) {\n  const pageSize = 64 * 1024;\n  return Math.ceil(bytes / pageSize);\n}\n\nmodule.exports = {\n  /**\n   * Takes in either an ArrayBuffer or WebAssembly.Module\n   * and will return a Promise of a LoadedPolicy object which\n   * can be used to evaluate the policy.\n   *\n   * To set custom memory size specify number of memory pages\n   * as second param.\n   * Defaults to 5 pages (320KB).\n   * @param {BufferSource | WebAssembly.Module | Response | Promise<Response>} regoWasm\n   * @param {number | WebAssembly.MemoryDescriptor} memoryDescriptor For backwards-compatibility, a 'number' argument is taken to be the initial memory size.\n   * @param {{ [builtinName: string]: Function }} customBuiltins A map from string names to builtin functions\n   * @returns {Promise<LoadedPolicy>}\n   */\n  async loadPolicy(regoWasm, memoryDescriptor = {}, customBuiltins = {}) {\n    // back-compat, second arg used to be a number: 'memorySize', with default of 5\n    if (typeof memoryDescriptor === \"number\") {\n      memoryDescriptor = { initial: memoryDescriptor };\n    }\n    memoryDescriptor.initial = memoryDescriptor.initial || 5;\n\n    const memory = new WebAssembly.Memory(memoryDescriptor);\n    const { policy, minorVersion } = await _loadPolicy(\n      regoWasm,\n      memory,\n      customBuiltins,\n    );\n    return new LoadedPolicy(policy, memory, minorVersion);\n  },\n\n  /**\n   * Takes in either an ArrayBuffer or WebAssembly.Module\n   * and will return a LoadedPolicy object which can be\n   * used to evaluate the policy.\n   *\n   * This cannot be used from the main thread in a browser.\n   * You must use the `loadPolicy` function instead, or call\n   * from a worker thread.\n   *\n   * To set custom memory size specify number of memory pages\n   * as second param.\n   * Defaults to 5 pages (320KB).\n   * @param {BufferSource | WebAssembly.Module} regoWasm\n   * @param {number | WebAssembly.MemoryDescriptor} memoryDescriptor For backwards-compatibility, a 'number' argument is taken to be the initial memory size.\n   * @param {{ [builtinName: string]: Function }} customBuiltins A map from string names to builtin functions\n   * @returns {LoadedPolicy}\n   */\n  loadPolicySync(regoWasm, memoryDescriptor = {}, customBuiltins = {}) {\n    // back-compat, second arg used to be a number: 'memorySize', with default of 5\n    if (typeof memoryDescriptor === \"number\") {\n      memoryDescriptor = { initial: memoryDescriptor };\n    }\n    memoryDescriptor.initial = memoryDescriptor.initial || 5;\n\n    const memory = new WebAssembly.Memory(memoryDescriptor);\n    const { policy, minorVersion } = _loadPolicySync(\n      regoWasm,\n      memory,\n      customBuiltins,\n    );\n    return new LoadedPolicy(policy, memory, minorVersion);\n  },\n  LoadedPolicy,\n};\n"],
  "mappings": "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",
  "names": ["require_json", "__commonJSMin", "exports", "module", "isValidJSON", "str", "err", "require_sprintf", "__commonJSMin", "exports", "re", "sprintf", "key", "sprintf_format", "sprintf_parse", "vsprintf", "fmt", "argv", "parse_tree", "cursor", "tree_length", "arg", "output", "i", "k", "ph", "pad", "pad_character", "pad_length", "is_positive", "sign", "sprintf_cache", "_fmt", "match", "arg_names", "field_list", "replacement_field", "field_match", "require_strings", "__commonJSMin", "exports", "module", "vsprintf", "sprintf", "values", "require_regex", "__commonJSMin", "exports", "module", "regexSplit", "pattern", "s", "require_PlainValue_ec8e588e", "__commonJSMin", "exports", "Char", "Type", "defaultTagPrefix", "defaultTags", "findLineStarts", "src", "ls", "offset", "getSrcInfo", "cst", "lineStarts", "getLinePos", "start", "line", "getLine", "end", "getPrettyContext", "maxWidth", "col", "halfWidth", "errLen", "errEnd", "err", "Range", "_Range", "orig", "cr", "nextOffset", "Node", "_Node", "str", "next", "sep", "ch0", "prev", "ch1", "ch2", "ch3", "ch", "isVerbatim", "notOk", "indent", "lineStart", "inEnd", "wsEnd", "endAsBlank", "indentDiff", "indicatorAsIndent", "inCount", "error", "fold", "type", "props", "context", "idx", "key", "skipKey", "prop", "i", "anchor", "comments", "comment", "tag", "_", "handle", "suffix", "commentRange", "range", "value", "YAMLError", "name", "source", "message", "ctx", "YAMLReferenceError", "YAMLSemanticError", "YAMLSyntaxError", "YAMLWarning", "_defineProperty", "obj", "PlainValue", "_PlainValue", "inFlow", "wsStart", "msg", "valueEnd", "require_parse_cst", "__commonJSMin", "exports", "PlainValue", "BlankLine", "context", "start", "CollectionItem", "type", "props", "parseNode", "src", "atLineStart", "lineStart", "indent", "offset", "ch", "inlineComment", "comments", "blankLine", "end", "wsEnd", "items", "c", "cr", "node", "range", "value", "str", "Comment", "grabCollectionEndComments", "cnode", "Collection", "len", "ci", "i", "n", "ca", "prevEnd", "_Collection", "firstItem", "itemRange", "ec", "prevIncludesTrailingLines", "comment", "next", "msg", "ls", "prev", "item", "Directive", "raw", "Document", "_Document", "hasDirectives", "directive", "iEnd", "contents", "directives", "Alias", "Chomp", "BlockValue", "lastNewLine", "keepStart", "bi", "folded", "atStart", "sep", "prevMoreIndented", "j", "lineEnd", "line", "explicit", "valueEnd", "minBlockIndent", "lineIndent", "FlowCollection", "idx", "char", "nodes", "prefix", "QuoteDouble", "_QuoteDouble", "errors", "fold", "error", "wsStart", "length", "cc", "code", "QuoteSingle", "_QuoteSingle", "createNewNode", "ParseContext", "_ParseContext", "inFlow", "orig", "inCollection", "parent", "overlay", "valueStart", "collection", "lineHasProps", "inEnd", "indentDiff", "noIndicatorAsIndent", "parse", "match", "documents", "doc", "crOffset", "require_resolveSeq_d03cb037", "__commonJSMin", "exports", "PlainValue", "addCommentBefore", "str", "indent", "comment", "addComment", "Node", "toJSON", "value", "arg", "ctx", "v", "i", "anchor", "res", "Scalar", "collectionFromPath", "schema", "path", "k", "a", "isEmptyPath", "Collection", "_Collection", "key", "rest", "node", "keepScalar", "n", "blockItem", "flowChars", "isMap", "itemIndent", "onComment", "onChompKeep", "indentStep", "stringify", "inFlow", "allNullValues", "chompKeep", "hasItemWithNewLine", "nodes", "item", "line", "start", "end", "strings", "sum", "s", "asItemIndex", "idx", "YAMLSeq", "it", "_", "seq", "stringifyKey", "jsKey", "Pair", "_Pair", "cb", "msg", "map", "stringKey", "pair", "indentSize", "indentSeq", "simpleKeys", "keyComment", "explicitKey", "doc", "vcb", "valueComment", "cs", "valueStr", "ws", "getAliasCount", "anchors", "Alias", "count", "c", "kc", "vc", "_Alias", "range", "source", "implicitKey", "inStringifyKey", "t", "maxAliasCount", "findPair", "items", "YAMLMap", "overwrite", "prev", "sortEntries", "Type", "MERGE_KEY", "Merge", "srcMap", "binaryOptions", "boolOptions", "intOptions", "nullOptions", "strOptions", "resolveScalar", "tags", "scalarFallback", "format", "test", "resolve", "match", "FOLD_FLOW", "FOLD_BLOCK", "FOLD_QUOTED", "consumeMoreIndentedLines", "text", "ch", "foldFlowLines", "mode", "indentAtStart", "lineWidth", "minContentWidth", "onFold", "onOverflow", "endStep", "folds", "escapedFolds", "split", "overflow", "escStart", "escEnd", "next", "j", "fold", "getFoldOptions", "containsDocumentMarker", "lineLengthOverLimit", "indentLength", "limit", "strLen", "doubleQuotedString", "jsonEncoding", "minMultiLineLength", "json", "code", "singleQuotedString", "blockString", "type", "literal", "header", "wsStart", "wsEnd", "m", "body", "plainString", "actualString", "stringifyString", "defaultType", "_stringify", "_type", "stringifyNumber", "minFractionDigits", "tag", "d", "checkFlowCollectionEnd", "errors", "cst", "char", "name", "lastItem", "err", "checkFlowCommentSpace", "getLongKeyError", "sk", "resolveComments", "collection", "comments", "afterKey", "before", "resolveString", "error", "resolveTagHandle", "handle", "suffix", "prefix", "p", "dtp", "vocab", "resolveTagName", "nonSpecific", "verbatim", "resolveByTagName", "tagName", "matchWithTest", "getFallbackTagName", "resolveTag", "fallback", "refError", "isCollectionItem", "resolveNodeProps", "hasAnchor", "hasTag", "props", "valueRange", "resolveNodeValue", "src", "resolveNode", "ca", "resolveMap", "resolveFlowMapItems", "resolveBlockMapItems", "hasCollectionKey", "iKey", "sources", "jKey", "warn", "valueHasPairComment", "lineStart", "resolvePairComment", "found", "cc", "keyStart", "valueNode", "pos", "origPos", "nextItem", "offset", "resolveSeq", "resolveFlowSeqItems", "resolveBlockSeqItems", "prevItem", "keyEnd", "require_warnings_1000a372", "__commonJSMin", "exports", "PlainValue", "resolveSeq", "binary", "value", "doc", "node", "src", "str", "buffer", "msg", "comment", "type", "ctx", "onComment", "onChompKeep", "s", "i", "lineWidth", "n", "lines", "o", "parsePairs", "cst", "seq", "item", "pair", "createPairs", "schema", "iterable", "pairs", "it", "key", "keys", "YAMLOMap", "_YAMLOMap", "_", "map", "parseOMap", "seenKeys", "createOMap", "omap", "YAMLSet", "_YAMLSet", "keepPair", "prev", "parseSet", "createSet", "set", "parseSexagesimal", "sign", "parts", "p", "stringifySexagesimal", "intTime", "floatTime", "timestamp", "year", "month", "day", "hour", "minute", "second", "millisec", "tz", "date", "d", "shouldWarn", "deprecation", "env", "warn", "warning", "emit", "warnFileDeprecation", "filename", "path", "warned", "warnOptionDeprecation", "name", "alternative", "require_Schema_88e323a7", "__commonJSMin", "exports", "PlainValue", "resolveSeq", "warnings", "createMap", "schema", "obj", "ctx", "map", "key", "value", "createSeq", "seq", "it", "v", "string", "item", "onComment", "onChompKeep", "failsafe", "intIdentify$2", "intResolve$1", "src", "part", "radix", "intStringify$1", "node", "prefix", "nullObj", "boolObj", "str", "octObj", "oct", "intObj", "hexObj", "hex", "nanObj", "nan", "expObj", "floatObj", "frac1", "frac2", "frac", "core", "intIdentify$1", "stringifyJSON", "json", "boolStringify", "intIdentify", "intResolve", "sign", "n", "intStringify", "yaml11", "bin", "abs", "f", "schemas", "tags", "findTagObject", "tagName", "match", "t", "tagObj", "createNode", "defaultPrefix", "onTagObj", "prevObjects", "wrapScalars", "prev", "alias", "getSchemaTags", "knownTags", "customTags", "schemaId", "keys", "tag", "sortMapEntriesByKey", "a", "b", "Schema", "_Schema", "merge", "sortMapEntries", "deprecatedCustomTags", "baseCtx", "createCtx", "k", "require_Document_9b4560a1", "__commonJSMin", "exports", "PlainValue", "resolveSeq", "Schema", "defaultOptions", "scalarOptions", "opt", "documentOptions", "stringifyTag", "doc", "tag", "priv", "vocab", "p", "dtp", "suffix", "ch", "getTagObject", "tags", "item", "match", "t", "tagObj", "obj", "name", "stringifyProps", "node", "anchors", "props", "anchor", "stringify", "ctx", "onComment", "onChompKeep", "schema", "createCtx", "o", "alias", "str", "Anchors", "_Anchors", "prefix", "sources", "merge", "s", "map", "a", "names", "i", "_cstAliases", "prev", "visit", "listTagNames", "parseContents", "contents", "comments", "body", "spaceBefore", "msg", "res", "cb", "cbNode", "resolveTagDirective", "tagPrefixes", "directive", "handle", "resolveYamlDirective", "version", "parseDirectives", "directives", "prevDoc", "directiveComments", "hasDirectives", "comment", "error", "copyTagPrefix", "assertCollection", "Document", "_Document", "options", "value", "path", "key", "keepScalar", "id", "customTags", "directivesEndMarker", "valueRange", "warn", "arg", "onAnchor", "keepBlobsInJSON", "mapAsMap", "maxAliasCount", "keep", "anchorNames", "count", "indentSize", "lines", "vd", "tagNames", "chompKeep", "contentComment", "require_dist", "__commonJSMin", "exports", "parseCst", "Document$1", "Schema", "PlainValue", "warnings", "createNode", "value", "wrapScalars", "tag", "options", "Document", "parseAllDocuments", "src", "stream", "prev", "cstDoc", "doc", "parseDocument", "cst", "errMsg", "parse", "warning", "stringify", "YAML", "require_yaml", "__commonJSMin", "exports", "module", "require_yaml", "__commonJSMin", "exports", "module", "yaml", "errors", "parse", "str", "YAML_SILENCE_WARNINGS_CACHED", "err", "data", "require_builtins", "__commonJSMin", "exports", "module", "json", "strings", "regex", "yaml", "require_opa", "__commonJSMin", "exports", "module", "builtIns", "stringDecoder", "mem", "addr", "i8", "s", "_loadJSON", "wasmInstance", "memory", "value", "valueBuf", "valueAsText", "valueBufLen", "rawAddr", "parsedAddr", "_dumpJSON", "_dumpJSONRaw", "buf", "idx", "utf8View", "jsonAsText", "builtinFuncs", "_builtinCall", "builtins", "customBuiltins", "builtinId", "builtInName", "impl", "argArray", "args", "i", "jsArg", "result", "_importObject", "env", "addr2string", "_ctx", "arg1", "arg2", "arg3", "arg4", "_preparePolicy", "wasm", "abiVersionGlobal", "abiVersion", "abiMinorVersionGlobal", "abiMinorVersion", "key", "_loadPolicy", "policyWasm", "isStreaming", "importObject", "_loadPolicySync", "LoadedPolicy", "policy", "minorVersion", "input", "entrypoint", "inputBuf", "inputLen", "inputAddr", "inputAsText", "delta", "pages", "roundup", "heapPtr", "ret", "ctxAddr", "resultAddr", "rs", "data", "bytes", "regoWasm", "memoryDescriptor"]
}
